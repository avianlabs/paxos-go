/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// TaxFormsAPIService TaxFormsAPI service
type TaxFormsAPIService service

type ApiListTaxFormRevisionsRequest struct {
	ctx context.Context
	ApiService *TaxFormsAPIService
	accountId *string
	taxYear *string
	formTypes *[]string
	revision *string
}

// Required. Account ID
func (r ApiListTaxFormRevisionsRequest) AccountId(accountId string) ApiListTaxFormRevisionsRequest {
	r.accountId = &accountId
	return r
}

// Required. Tax Year
func (r ApiListTaxFormRevisionsRequest) TaxYear(taxYear string) ApiListTaxFormRevisionsRequest {
	r.taxYear = &taxYear
	return r
}

// Tax forms 1009 B or Misc
func (r ApiListTaxFormRevisionsRequest) FormTypes(formTypes []string) ApiListTaxFormRevisionsRequest {
	r.formTypes = &formTypes
	return r
}

// Revision
func (r ApiListTaxFormRevisionsRequest) Revision(revision string) ApiListTaxFormRevisionsRequest {
	r.revision = &revision
	return r
}

func (r ApiListTaxFormRevisionsRequest) Execute() (*ListTaxFormRevisionsResponse, *http.Response, error) {
	return r.ApiService.ListTaxFormRevisionsExecute(r)
}

/*
ListTaxFormRevisions List Tax Form Revisions

Used for more granular file retrieval for specific accounts that require updated tax forms.
Lists all versions of a tax form for single account and tax year. Revisions will increment up as new tax forms are issued for the same account, tax year, and form type pairing. The highest value revision is the most recent.
Tax Form URL links will expire after 60 seconds.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTaxFormRevisionsRequest
*/
func (a *TaxFormsAPIService) ListTaxFormRevisions(ctx context.Context) ApiListTaxFormRevisionsRequest {
	return ApiListTaxFormRevisionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTaxFormRevisionsResponse
func (a *TaxFormsAPIService) ListTaxFormRevisionsExecute(r ApiListTaxFormRevisionsRequest) (*ListTaxFormRevisionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTaxFormRevisionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxFormsAPIService.ListTaxFormRevisions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax/tax-form-revisions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.accountId == nil {
		return localVarReturnValue, nil, reportError("accountId is required and must be specified")
	}
	if r.taxYear == nil {
		return localVarReturnValue, nil, reportError("taxYear is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "tax_year", r.taxYear, "form", "")
	if r.formTypes != nil {
		t := *r.formTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "form_types", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "form_types", t, "form", "multi")
		}
	}
	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTaxFormsRequest struct {
	ctx context.Context
	ApiService *TaxFormsAPIService
	taxYear *string
	accountIds *[]string
	formTypes *[]string
	usersLimit *int32
	orderBy *string
	order *string
	pageCursor *string
}

// Required. Tax year
func (r ApiListTaxFormsRequest) TaxYear(taxYear string) ApiListTaxFormsRequest {
	r.taxYear = &taxYear
	return r
}

// Optional. A list of Account IDs. Maximum 50.
func (r ApiListTaxFormsRequest) AccountIds(accountIds []string) ApiListTaxFormsRequest {
	r.accountIds = &accountIds
	return r
}

// Form types
func (r ApiListTaxFormsRequest) FormTypes(formTypes []string) ApiListTaxFormsRequest {
	r.formTypes = &formTypes
	return r
}

// Number of results to return. Defaults to 50.
func (r ApiListTaxFormsRequest) UsersLimit(usersLimit int32) ApiListTaxFormsRequest {
	r.usersLimit = &usersLimit
	return r
}

// The specific method by which the returned results will be ordered. Defaults to ID.
func (r ApiListTaxFormsRequest) OrderBy(orderBy string) ApiListTaxFormsRequest {
	r.orderBy = &orderBy
	return r
}

// Return items in ascending (ASC) or descending (DESC) order. Defaults to ASC.
func (r ApiListTaxFormsRequest) Order(order string) ApiListTaxFormsRequest {
	r.order = &order
	return r
}

// Cursor token for fetching the next page.
func (r ApiListTaxFormsRequest) PageCursor(pageCursor string) ApiListTaxFormsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiListTaxFormsRequest) Execute() (*ListTaxFormsResponse, *http.Response, error) {
	return r.ApiService.ListTaxFormsExecute(r)
}

/*
ListTaxForms List Tax Forms

Used for bulk file transfer use cases.
List tax forms for given account ids and tax year. The most recent revision number will be returned (revisions increment up; highest value revision for a specific account, tax year, and form type pairing is the most recent).
Tax Form URL links will expire after 60 seconds.
Please call ListTaxFormRevisions endpoint for all versions of a single accounts tax forms.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTaxFormsRequest
*/
func (a *TaxFormsAPIService) ListTaxForms(ctx context.Context) ApiListTaxFormsRequest {
	return ApiListTaxFormsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTaxFormsResponse
func (a *TaxFormsAPIService) ListTaxFormsExecute(r ApiListTaxFormsRequest) (*ListTaxFormsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTaxFormsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxFormsAPIService.ListTaxForms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax/tax-forms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.taxYear == nil {
		return localVarReturnValue, nil, reportError("taxYear is required and must be specified")
	}

	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "tax_year", r.taxYear, "form", "")
	if r.formTypes != nil {
		t := *r.formTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "form_types", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "form_types", t, "form", "multi")
		}
	}
	if r.usersLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "users_limit", r.usersLimit, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
