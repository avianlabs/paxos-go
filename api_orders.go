/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// OrdersAPIService OrdersAPI service
type OrdersAPIService service

type ApiCancelOrderRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	profileId string
	id string
}

func (r ApiCancelOrderRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CancelOrderExecute(r)
}

/*
CancelOrder Cancel Order

Submits a cancellation request. A response indicates that the request has been acknowledged and provides no
guarantee the order has been cancelled.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile ID associated with the order.
 @param id The UUID of the Order.
 @return ApiCancelOrderRequest
*/
func (a *OrdersAPIService) CancelOrder(ctx context.Context, profileId string, id string) ApiCancelOrderRequest {
	return ApiCancelOrderRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		id: id,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *OrdersAPIService) CancelOrderExecute(r ApiCancelOrderRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.CancelOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profile_id}/orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"profile_id"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	profileId string
	exchangePublicCreateOrderBody *ExchangePublicCreateOrderBody
}

func (r ApiCreateOrderRequest) ExchangePublicCreateOrderBody(exchangePublicCreateOrderBody ExchangePublicCreateOrderBody) ApiCreateOrderRequest {
	r.exchangePublicCreateOrderBody = &exchangePublicCreateOrderBody
	return r
}

func (r ApiCreateOrderRequest) Execute() (*Order, *http.Response, error) {
	return r.ApiService.CreateOrderExecute(r)
}

/*
CreateOrder Create Order

For limit orders, create an order for buying or selling an asset:

- To buy, set `side = BUY` and set `base_amount` to the crypto amount you want to buy.
- To sell, set `side = SELL` and set `base_amount` to the crypto amount you want to sell.

For market orders, create an order for buying or selling an asset:

- To buy, set `side = BUY` and set `quote_amount` to the dollar amount you want to spend.
- To sell, set `side = SELL` and set `base_amount` to the crypto amount you want to sell.

There are five types of orders:

- Limit Orders: Buy or sell at a specified price or better. Execution not guaranteed. Taker orders will be rejected if price deviates 15% from midpoint.
- Post-Only Limit Orders: have the same properties as Limit Orders, but get rejected if they cross the orderbook.
- Market Orders: Operate as Immediate or Cancel (IOC) orders. Price is variable, executes at best available price at time of order.
- Stop Market Orders: Will convert to a market sell order with the specified quantity when the stop price is hit. The stop price does not guarantee that it will be executed at that price. Market conditions (price) might change between the order being triggered and order being executed. Currently only sell stop loss orders are supported.
- Stop Limit Orders: have a Stop Price which when hit, will convert to a limit sell order that will be executed at a specified price (or better)

Maximum notional order size by type:

Order Type | Market  | Maximum Notional Value (USD)
---------- | ------- | ----------------------------
Market     | all     | 500,000
Limit      | BTCUSD  | 1,500,000
Limit      | ETHUSD  | 1,500,000
Limit      | other   | 1,000,000

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profileId the order will be associated with.
 @return ApiCreateOrderRequest
*/
func (a *OrdersAPIService) CreateOrder(ctx context.Context, profileId string) ApiCreateOrderRequest {
	return ApiCreateOrderRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
	}
}

// Execute executes the request
//  @return Order
func (a *OrdersAPIService) CreateOrderExecute(r ApiCreateOrderRequest) (*Order, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.CreateOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profile_id}/orders"
	localVarPath = strings.Replace(localVarPath, "{"+"profile_id"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangePublicCreateOrderBody == nil {
		return localVarReturnValue, nil, reportError("exchangePublicCreateOrderBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exchangePublicCreateOrderBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	profileId string
	id string
}

func (r ApiGetOrderRequest) Execute() (*Order, *http.Response, error) {
	return r.ApiService.GetOrderExecute(r)
}

/*
GetOrder Get Order

Retrieves the current state of an order.
- Historical data prior to May 16, 2022 is unavailable.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param profileId The profile ID associated with the order.
 @param id The UUID of the Order.
 @return ApiGetOrderRequest
*/
func (a *OrdersAPIService) GetOrder(ctx context.Context, profileId string, id string) ApiGetOrderRequest {
	return ApiGetOrderRequest{
		ApiService: a,
		ctx: ctx,
		profileId: profileId,
		id: id,
	}
}

// Execute executes the request
//  @return Order
func (a *OrdersAPIService) GetOrderExecute(r ApiGetOrderRequest) (*Order, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.GetOrder")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profiles/{profile_id}/orders/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"profile_id"+"}", url.PathEscape(parameterValueToString(r.profileId, "profileId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListExecutionsRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	profileId *string
	accountId *string
	orderId *string
	sinceExecutionId *string
	rangeBegin *time.Time
	rangeEnd *time.Time
	pageCursor *string
	limit *int32
}

// Filter executions by the Profile ID associated with the orders.
func (r ApiListExecutionsRequest) ProfileId(profileId string) ApiListExecutionsRequest {
	r.profileId = &profileId
	return r
}

// Filter executions by the Account ID associated with the orders.
func (r ApiListExecutionsRequest) AccountId(accountId string) ApiListExecutionsRequest {
	r.accountId = &accountId
	return r
}

// Filter executions for a single order ID.
func (r ApiListExecutionsRequest) OrderId(orderId string) ApiListExecutionsRequest {
	r.orderId = &orderId
	return r
}

// Excludes executions after the given ID.
func (r ApiListExecutionsRequest) SinceExecutionId(sinceExecutionId string) ApiListExecutionsRequest {
	r.sinceExecutionId = &sinceExecutionId
	return r
}

// Only return records after this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListExecutionsRequest) RangeBegin(rangeBegin time.Time) ApiListExecutionsRequest {
	r.rangeBegin = &rangeBegin
	return r
}

// Only return records before this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListExecutionsRequest) RangeEnd(rangeEnd time.Time) ApiListExecutionsRequest {
	r.rangeEnd = &rangeEnd
	return r
}

// Cursor token for fetching the next page.
func (r ApiListExecutionsRequest) PageCursor(pageCursor string) ApiListExecutionsRequest {
	r.pageCursor = &pageCursor
	return r
}

// Number of results to return.
func (r ApiListExecutionsRequest) Limit(limit int32) ApiListExecutionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListExecutionsRequest) Execute() (*ListExecutionsResponse, *http.Response, error) {
	return r.ApiService.ListExecutionsExecute(r)
}

/*
ListExecutions List Executions

Retrieves full details of underlying executions with optional filters.
Notes:
- This endpoint returns a maximum of 1000 items per page.
- Filtering options are `account_id`, `profile_id` or neither (all executions).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListExecutionsRequest
*/
func (a *OrdersAPIService) ListExecutions(ctx context.Context) ApiListExecutionsRequest {
	return ApiListExecutionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListExecutionsResponse
func (a *OrdersAPIService) ListExecutionsExecute(r ApiListExecutionsRequest) (*ListExecutionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListExecutionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.ListExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/executions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", r.profileId, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.orderId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_id", r.orderId, "")
	}
	if r.sinceExecutionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "since_execution_id", r.sinceExecutionId, "")
	}
	if r.rangeBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range.begin", r.rangeBegin, "")
	}
	if r.rangeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "range.end", r.rangeEnd, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrdersRequest struct {
	ctx context.Context
	ApiService *OrdersAPIService
	profileId *string
	accountId *string
	market *string
	status *string
	orderTimeBegin *time.Time
	orderTimeEnd *time.Time
	refIds *[]string
	pageCursor *string
	limit *int32
}

// The profile associated with the orders.
func (r ApiListOrdersRequest) ProfileId(profileId string) ApiListOrdersRequest {
	r.profileId = &profileId
	return r
}

// The account under which these orders are placed.
func (r ApiListOrdersRequest) AccountId(accountId string) ApiListOrdersRequest {
	r.accountId = &accountId
	return r
}

// Filter by the trading pair.
func (r ApiListOrdersRequest) Market(market string) ApiListOrdersRequest {
	r.market = &market
	return r
}

// Filter by the status of the order.
func (r ApiListOrdersRequest) Status(status string) ApiListOrdersRequest {
	r.status = &status
	return r
}

// Only return records after this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrdersRequest) OrderTimeBegin(orderTimeBegin time.Time) ApiListOrdersRequest {
	r.orderTimeBegin = &orderTimeBegin
	return r
}

// Only return records before this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrdersRequest) OrderTimeEnd(orderTimeEnd time.Time) ApiListOrdersRequest {
	r.orderTimeEnd = &orderTimeEnd
	return r
}

// The idempotence IDs provided during order creation.
func (r ApiListOrdersRequest) RefIds(refIds []string) ApiListOrdersRequest {
	r.refIds = &refIds
	return r
}

// Cursor token for fetching the next page. If using this then do not use paginationLimit and paginationOffset fields.
func (r ApiListOrdersRequest) PageCursor(pageCursor string) ApiListOrdersRequest {
	r.pageCursor = &pageCursor
	return r
}

// Number of results to return. If using this then do not use paginationLimit and paginationOffset fields.
func (r ApiListOrdersRequest) Limit(limit int32) ApiListOrdersRequest {
	r.limit = &limit
	return r
}

func (r ApiListOrdersRequest) Execute() (*ListOrdersResponse, *http.Response, error) {
	return r.ApiService.ListOrdersExecute(r)
}

/*
ListOrders List Orders

Retrieves full details of orders associated with a Profile ID, with optional filters.

- Historical data prior to May 16, 2022 is unavailable.
- Pagination Limit has a max of 1000. Pagination Offset is now deprecated and nonfunctional.
- Filtering options are `account_id`, `profile_id` or neither (all orders).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrdersRequest
*/
func (a *OrdersAPIService) ListOrders(ctx context.Context) ApiListOrdersRequest {
	return ApiListOrdersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOrdersResponse
func (a *OrdersAPIService) ListOrdersExecute(r ApiListOrdersRequest) (*ListOrdersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrdersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrdersAPIService.ListOrders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", r.profileId, "")
	}
	if r.accountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_id", r.accountId, "")
	}
	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.orderTimeBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_time.begin", r.orderTimeBegin, "")
	}
	if r.orderTimeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_time.end", r.orderTimeEnd, "")
	}
	if r.refIds != nil {
		t := *r.refIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ref_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ref_ids", t, "multi")
		}
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
