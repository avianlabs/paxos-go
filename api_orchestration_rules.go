/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// OrchestrationRulesAPIService OrchestrationRulesAPI service
type OrchestrationRulesAPIService service

type ApiCreateOrchestrationRuleRequest struct {
	ctx context.Context
	ApiService *OrchestrationRulesAPIService
	createOrchestrationRuleRequest *CreateOrchestrationRuleRequest
}

func (r ApiCreateOrchestrationRuleRequest) CreateOrchestrationRuleRequest(createOrchestrationRuleRequest CreateOrchestrationRuleRequest) ApiCreateOrchestrationRuleRequest {
	r.createOrchestrationRuleRequest = &createOrchestrationRuleRequest
	return r
}

func (r ApiCreateOrchestrationRuleRequest) Execute() (*CreateOrchestrationRuleResponse, *http.Response, error) {
	return r.ApiService.CreateOrchestrationRuleExecute(r)
}

/*
CreateOrchestrationRule Create Orchestration Rule

Creates a persistent orchestration rule that automatically triggers orchestrations
when matching deposits are received.

The rule will:
1. Generate deposit instructions associated with the rule.
2. Continuously monitor incoming deposits to those instructions.
3. Automatically execute orchestrations to the specified destination.

Supported Sources:

- Crypto deposit
- Fiat deposit

Supported Destinations:

- Crypto address on a supported network
- Bank account
- Profile ID

Error conditions:
- [Already Exists](https://developer.paxos.com/docs/v2/problems/already-exists): Returned if a rule with the same ref_id already exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrchestrationRuleRequest
*/
func (a *OrchestrationRulesAPIService) CreateOrchestrationRule(ctx context.Context) ApiCreateOrchestrationRuleRequest {
	return ApiCreateOrchestrationRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateOrchestrationRuleResponse
func (a *OrchestrationRulesAPIService) CreateOrchestrationRuleExecute(r ApiCreateOrchestrationRuleRequest) (*CreateOrchestrationRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateOrchestrationRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestrationRulesAPIService.CreateOrchestrationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orchestration/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrchestrationRuleRequest == nil {
		return localVarReturnValue, nil, reportError("createOrchestrationRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrchestrationRuleRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrchestrationRuleRequest struct {
	ctx context.Context
	ApiService *OrchestrationRulesAPIService
	id string
}

func (r ApiDeleteOrchestrationRuleRequest) Execute() (*DeleteOrchestrationRuleResponse, *http.Response, error) {
	return r.ApiService.DeleteOrchestrationRuleExecute(r)
}

/*
DeleteOrchestrationRule Delete Orchestration Rule

Deactivates an orchestration rule by updating its status to DELETED.
Once deleted, the rule will no longer trigger new orchestrations.
Any orchestrations previously created by the rule will continue to be processed.

The request accepts a single rule ID and returns the updated rule resource
with its status set to DELETED upon success.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the orchestration rule to delete
 @return ApiDeleteOrchestrationRuleRequest
*/
func (a *OrchestrationRulesAPIService) DeleteOrchestrationRule(ctx context.Context, id string) ApiDeleteOrchestrationRuleRequest {
	return ApiDeleteOrchestrationRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return DeleteOrchestrationRuleResponse
func (a *OrchestrationRulesAPIService) DeleteOrchestrationRuleExecute(r ApiDeleteOrchestrationRuleRequest) (*DeleteOrchestrationRuleResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteOrchestrationRuleResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestrationRulesAPIService.DeleteOrchestrationRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orchestration/rules/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrchestrationRulesRequest struct {
	ctx context.Context
	ApiService *OrchestrationRulesAPIService
	profileId *string
	status *[]string
	sourceAsset *string
	destinationAsset *string
	ids *[]string
	limit *int32
	order *string
	pageCursor *string
}

// Optional filter by profile ID
func (r ApiListOrchestrationRulesRequest) ProfileId(profileId string) ApiListOrchestrationRulesRequest {
	r.profileId = &profileId
	return r
}

// Optional filter by statuses   - ACTIVE: The rule is active, deposits matching the &#x60;source_asset&#x60; and &#x60;source&#x60; of this rule start a conversion and subsequent delivery of the &#x60;destination_asset&#x60; to the specified &#x60;destination&#x60;.  - DELETED: The rule has been deleted, newly deposited &#x60;source_assets&#x60; to the &#x60;source&#x60; of this rule will not be converted. The deposited &#x60;source_asset&#x60; is still going to be credited to the Profile specified by &#x60;profile_id&#x60;.  - PENDING: The rule creation is pending approval(s) before the rule becomes ACTIVE.  - REJECTED: The rule creation has been rejected during the approval process.  - CANCELLED: The rule creation has been cancelled before it could be approved.
func (r ApiListOrchestrationRulesRequest) Status(status []string) ApiListOrchestrationRulesRequest {
	r.status = &status
	return r
}

// Optional filter by source asset
func (r ApiListOrchestrationRulesRequest) SourceAsset(sourceAsset string) ApiListOrchestrationRulesRequest {
	r.sourceAsset = &sourceAsset
	return r
}

// Optional filter by destination asset
func (r ApiListOrchestrationRulesRequest) DestinationAsset(destinationAsset string) ApiListOrchestrationRulesRequest {
	r.destinationAsset = &destinationAsset
	return r
}

// Optionally filter by the UUIDs of the orchestration rules. Limit 100.
func (r ApiListOrchestrationRulesRequest) Ids(ids []string) ApiListOrchestrationRulesRequest {
	r.ids = &ids
	return r
}

// Number of results to return. Defaults to 100 if no limit is provided. Maximum 1000.
func (r ApiListOrchestrationRulesRequest) Limit(limit int32) ApiListOrchestrationRulesRequest {
	r.limit = &limit
	return r
}

// Sort order for the results. Defaults to DESC by created_at time.
func (r ApiListOrchestrationRulesRequest) Order(order string) ApiListOrchestrationRulesRequest {
	r.order = &order
	return r
}

// Optional Cursor for getting the next page of results.
func (r ApiListOrchestrationRulesRequest) PageCursor(pageCursor string) ApiListOrchestrationRulesRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiListOrchestrationRulesRequest) Execute() (*ListOrchestrationRulesResponse, *http.Response, error) {
	return r.ApiService.ListOrchestrationRulesExecute(r)
}

/*
ListOrchestrationRules List Orchestration Rules

List all orchestration rules, optionally filtering and paging the results.

By default, orchestration rules are returned in reverse chronological (descending)
order by creation time. If no query parameters are supplied,
the response will include up to the last 100 rules which were created.

The paginated results default to display up to 100 rules, unless
otherwise specified with the `limit` parameter. The maximum `limit` value is 1000.
Every paginated response contains a `next_page_cursor` field until the last page is reached.

Pass the `next_page_cursor` value into the `page_cursor` field of a new
request to retrieve the next page of results.

Rules can be filtered by:
- Profile ID (`profile_id`)
- Status (`status`)
- Source asset (`source_asset`)
- Destination asset (`destination_asset`)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrchestrationRulesRequest
*/
func (a *OrchestrationRulesAPIService) ListOrchestrationRules(ctx context.Context) ApiListOrchestrationRulesRequest {
	return ApiListOrchestrationRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOrchestrationRulesResponse
func (a *OrchestrationRulesAPIService) ListOrchestrationRulesExecute(r ApiListOrchestrationRulesRequest) (*ListOrchestrationRulesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrchestrationRulesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestrationRulesAPIService.ListOrchestrationRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orchestration/rules"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", r.profileId, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.sourceAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source_asset", r.sourceAsset, "")
	}
	if r.destinationAsset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "destination_asset", r.destinationAsset, "")
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
