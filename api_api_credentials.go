/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// APICredentialsAPIService APICredentialsAPI service
type APICredentialsAPIService service

type ApiDeleteApiCredentialsRequest struct {
	ctx context.Context
	ApiService *APICredentialsAPIService
	clientId string
}

func (r ApiDeleteApiCredentialsRequest) Execute() (*DeleteApiCredentialsResponse, *http.Response, error) {
	return r.ApiService.DeleteApiCredentialsExecute(r)
}

/*
DeleteApiCredentials Delete API Credentials

Delete the given API Credentials, preventing them from being used for authentication.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param clientId The client_id of the credentials to delete.
 @return ApiDeleteApiCredentialsRequest
*/
func (a *APICredentialsAPIService) DeleteApiCredentials(ctx context.Context, clientId string) ApiDeleteApiCredentialsRequest {
	return ApiDeleteApiCredentialsRequest{
		ApiService: a,
		ctx: ctx,
		clientId: clientId,
	}
}

// Execute executes the request
//  @return DeleteApiCredentialsResponse
func (a *APICredentialsAPIService) DeleteApiCredentialsExecute(r ApiDeleteApiCredentialsRequest) (*DeleteApiCredentialsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteApiCredentialsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APICredentialsAPIService.DeleteApiCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-creds/credentials/{client_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"client_id"+"}", url.PathEscape(parameterValueToString(r.clientId, "clientId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApiCredentialsRequest struct {
	ctx context.Context
	ApiService *APICredentialsAPIService
	order *string
	orderBy *string
	limit *int32
	pageCursor *string
	statuses *[]string
	ids *[]string
	clientIds *[]string
}

// Determines whether the items are returned in ascending (ASC), or descending (DESC) order. Defaults to DESC.
func (r ApiListApiCredentialsRequest) Order(order string) ApiListApiCredentialsRequest {
	r.order = &order
	return r
}

// The specific field by which the returned results will be ordered. Defaults to CREATED_AT.
func (r ApiListApiCredentialsRequest) OrderBy(orderBy string) ApiListApiCredentialsRequest {
	r.orderBy = &orderBy
	return r
}

// The maximum number of items to return. Defaults to 0 (return all records). Max value is 1000.
func (r ApiListApiCredentialsRequest) Limit(limit int32) ApiListApiCredentialsRequest {
	r.limit = &limit
	return r
}

// The page cursor for pagination. Use the next_page_cursor from the response to get the next page.
func (r ApiListApiCredentialsRequest) PageCursor(pageCursor string) ApiListApiCredentialsRequest {
	r.pageCursor = &pageCursor
	return r
}

// Filter for credentials with a set of statuses. Defaults to [APPROVED].
func (r ApiListApiCredentialsRequest) Statuses(statuses []string) ApiListApiCredentialsRequest {
	r.statuses = &statuses
	return r
}

// Optionally filter by the UUIDs of the credentials. Limit 100.
func (r ApiListApiCredentialsRequest) Ids(ids []string) ApiListApiCredentialsRequest {
	r.ids = &ids
	return r
}

// Optionally filter by the client IDs of the credentials. Limit 100.
func (r ApiListApiCredentialsRequest) ClientIds(clientIds []string) ApiListApiCredentialsRequest {
	r.clientIds = &clientIds
	return r
}

func (r ApiListApiCredentialsRequest) Execute() (*ListApiCredentialsResponse, *http.Response, error) {
	return r.ApiService.ListApiCredentialsExecute(r)
}

/*
ListApiCredentials List API Credentials

List all API credentials that have been created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListApiCredentialsRequest
*/
func (a *APICredentialsAPIService) ListApiCredentials(ctx context.Context) ApiListApiCredentialsRequest {
	return ApiListApiCredentialsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListApiCredentialsResponse
func (a *APICredentialsAPIService) ListApiCredentialsExecute(r ApiListApiCredentialsRequest) (*ListApiCredentialsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListApiCredentialsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APICredentialsAPIService.ListApiCredentials")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-creds/credentials"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.statuses != nil {
		t := *r.statuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", t, "multi")
		}
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.clientIds != nil {
		t := *r.clientIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "client_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "client_ids", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
