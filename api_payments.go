/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// PaymentsAPIService PaymentsAPI service
type PaymentsAPIService service

type ApiListPaymentsRequest struct {
	ctx context.Context
	ApiService *PaymentsAPIService
	refIds *[]string
	paymentIds *[]string
	customerId *string
	product *string
	paymentStatus *string
	limit *int32
	order *string
	pageCursor *string
}

// No other parameters are allowed if ref_ids are provided
func (r ApiListPaymentsRequest) RefIds(refIds []string) ApiListPaymentsRequest {
	r.refIds = &refIds
	return r
}

// No other parameters are allowed if payment_ids are provided
func (r ApiListPaymentsRequest) PaymentIds(paymentIds []string) ApiListPaymentsRequest {
	r.paymentIds = &paymentIds
	return r
}

// Use together with product to list for a specific customer and product
func (r ApiListPaymentsRequest) CustomerId(customerId string) ApiListPaymentsRequest {
	r.customerId = &customerId
	return r
}

// Use together with product to list for a specific customer and product
func (r ApiListPaymentsRequest) Product(product string) ApiListPaymentsRequest {
	r.product = &product
	return r
}

// Optional, filter by payment status
func (r ApiListPaymentsRequest) PaymentStatus(paymentStatus string) ApiListPaymentsRequest {
	r.paymentStatus = &paymentStatus
	return r
}

// Number of results to return. Defaults to 100 if no limit is provided.
func (r ApiListPaymentsRequest) Limit(limit int32) ApiListPaymentsRequest {
	r.limit = &limit
	return r
}

// Sort order for the results by created at, defaults to DESC if not provided.
func (r ApiListPaymentsRequest) Order(order string) ApiListPaymentsRequest {
	r.order = &order
	return r
}

// Cursor for getting the next page of results.
func (r ApiListPaymentsRequest) PageCursor(pageCursor string) ApiListPaymentsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiListPaymentsRequest) Execute() (*ListPaymentsResponse, *http.Response, error) {
	return r.ApiService.ListPaymentsExecute(r)
}

/*
ListPayments List Payments

List payments based on the provided filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPaymentsRequest
*/
func (a *PaymentsAPIService) ListPayments(ctx context.Context) ApiListPaymentsRequest {
	return ApiListPaymentsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListPaymentsResponse
func (a *PaymentsAPIService) ListPaymentsExecute(r ApiListPaymentsRequest) (*ListPaymentsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListPaymentsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentsAPIService.ListPayments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/statements/payments"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refIds != nil {
		t := *r.refIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ref_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ref_ids", t, "multi")
		}
	}
	if r.paymentIds != nil {
		t := *r.paymentIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "payment_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "payment_ids", t, "multi")
		}
	}
	if r.customerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer_id", r.customerId, "")
	}
	if r.product != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "product", r.product, "")
	}
	if r.paymentStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payment_status", r.paymentStatus, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
