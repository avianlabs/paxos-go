/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// StablecoinConversionAPIService StablecoinConversionAPI service
type StablecoinConversionAPIService service

type ApiCancelStablecoinConversionRequest struct {
	ctx context.Context
	ApiService *StablecoinConversionAPIService
	id string
}

func (r ApiCancelStablecoinConversionRequest) Execute() (*StablecoinConversion, *http.Response, error) {
	return r.ApiService.CancelStablecoinConversionExecute(r)
}

/*
CancelStablecoinConversion Cancel Stablecoin Conversion

Cancel a single conversion using the `id` from the
[Create Stablecoin Conversion](#operation/CreateStablecoinConversion) response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id System provided UUID for the conversion is provided in the [Create Stablecoin Conversion](#operation/CreateStablecoinConversion) response.
 @return ApiCancelStablecoinConversionRequest
*/
func (a *StablecoinConversionAPIService) CancelStablecoinConversion(ctx context.Context, id string) ApiCancelStablecoinConversionRequest {
	return ApiCancelStablecoinConversionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StablecoinConversion
func (a *StablecoinConversionAPIService) CancelStablecoinConversionExecute(r ApiCancelStablecoinConversionRequest) (*StablecoinConversion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StablecoinConversion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StablecoinConversionAPIService.CancelStablecoinConversion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversion/stablecoins/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateStablecoinConversionRequest struct {
	ctx context.Context
	ApiService *StablecoinConversionAPIService
	createStablecoinConversionRequest *CreateStablecoinConversionRequest
}

func (r ApiCreateStablecoinConversionRequest) CreateStablecoinConversionRequest(createStablecoinConversionRequest CreateStablecoinConversionRequest) ApiCreateStablecoinConversionRequest {
	r.createStablecoinConversionRequest = &createStablecoinConversionRequest
	return r
}

func (r ApiCreateStablecoinConversionRequest) Execute() (*StablecoinConversion, *http.Response, error) {
	return r.ApiService.CreateStablecoinConversionExecute(r)
}

/*
CreateStablecoinConversion Create Stablecoin Conversion

Create a Conversion request to exchange assets 1:1.

A request to create a conversion can fail with one of the following
types of errors:
 - [Insufficient Funds](https://developer.paxos.com/docs/v2/problems/insufficient-funds)
   if the Profile (`profile_id`) has insufficient available balance to
   fund the execution.
 - [Already Exists](https://developer.paxos.com/docs/v2/problems/already-exists)
   if a conversion with the same external ID (`ref_id`) has already been created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateStablecoinConversionRequest
*/
func (a *StablecoinConversionAPIService) CreateStablecoinConversion(ctx context.Context) ApiCreateStablecoinConversionRequest {
	return ApiCreateStablecoinConversionRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StablecoinConversion
func (a *StablecoinConversionAPIService) CreateStablecoinConversionExecute(r ApiCreateStablecoinConversionRequest) (*StablecoinConversion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StablecoinConversion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StablecoinConversionAPIService.CreateStablecoinConversion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversion/stablecoins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createStablecoinConversionRequest == nil {
		return localVarReturnValue, nil, reportError("createStablecoinConversionRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createStablecoinConversionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStablecoinConversionRequest struct {
	ctx context.Context
	ApiService *StablecoinConversionAPIService
	id string
}

func (r ApiGetStablecoinConversionRequest) Execute() (*StablecoinConversion, *http.Response, error) {
	return r.ApiService.GetStablecoinConversionExecute(r)
}

/*
GetStablecoinConversion Get Stablecoin Conversion

Retrieve a single conversion using the transaction `id` from the [Create Stablecoin Conversion](#operation/CreateStablecoinConversion) response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id System provided UUID for the conversion is provided in the [Create Stablecoin Conversion](#operation/CreateStablecoinConversion) response.
 @return ApiGetStablecoinConversionRequest
*/
func (a *StablecoinConversionAPIService) GetStablecoinConversion(ctx context.Context, id string) ApiGetStablecoinConversionRequest {
	return ApiGetStablecoinConversionRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return StablecoinConversion
func (a *StablecoinConversionAPIService) GetStablecoinConversionExecute(r ApiGetStablecoinConversionRequest) (*StablecoinConversion, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StablecoinConversion
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StablecoinConversionAPIService.GetStablecoinConversion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversion/stablecoins/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListStablecoinConversionsRequest struct {
	ctx context.Context
	ApiService *StablecoinConversionAPIService
	profileId *string
	refId *string
	createdAtBegin *time.Time
	createdAtEnd *time.Time
	updatedAtBegin *time.Time
	updatedAtEnd *time.Time
	order *string
	pageCursor *string
	limit *int32
}

// The &lt;a href&#x3D;\&quot;#tag/Profiles\&quot;&gt;Profile&lt;/a&gt; associated with a conversion. Required in the &lt;a href&#x3D;\&quot;#operation/CreateStablecoinConversion\&quot;&gt;Create Stablecoin Conversion&lt;/a&gt; request.
func (r ApiListStablecoinConversionsRequest) ProfileId(profileId string) ApiListStablecoinConversionsRequest {
	r.profileId = &profileId
	return r
}

// Client provided, unique Reference ID included the &lt;a href&#x3D;\&quot;#operation/CreateStablecoinConversion\&quot;&gt;Create Stablecoin Conversion&lt;/a&gt; request.
func (r ApiListStablecoinConversionsRequest) RefId(refId string) ApiListStablecoinConversionsRequest {
	r.refId = &refId
	return r
}

// Only return records after this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListStablecoinConversionsRequest) CreatedAtBegin(createdAtBegin time.Time) ApiListStablecoinConversionsRequest {
	r.createdAtBegin = &createdAtBegin
	return r
}

// Only return records before this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListStablecoinConversionsRequest) CreatedAtEnd(createdAtEnd time.Time) ApiListStablecoinConversionsRequest {
	r.createdAtEnd = &createdAtEnd
	return r
}

// Only return records after this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListStablecoinConversionsRequest) UpdatedAtBegin(updatedAtBegin time.Time) ApiListStablecoinConversionsRequest {
	r.updatedAtBegin = &updatedAtBegin
	return r
}

// Only return records before this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListStablecoinConversionsRequest) UpdatedAtEnd(updatedAtEnd time.Time) ApiListStablecoinConversionsRequest {
	r.updatedAtEnd = &updatedAtEnd
	return r
}

// Return items in ascending (ASC) or descending (DESC) order by &#x60;created_at&#x60; timestamp.  Default order is descending (DESC).
func (r ApiListStablecoinConversionsRequest) Order(order string) ApiListStablecoinConversionsRequest {
	r.order = &order
	return r
}

// Cursor token for fetching the next page.
func (r ApiListStablecoinConversionsRequest) PageCursor(pageCursor string) ApiListStablecoinConversionsRequest {
	r.pageCursor = &pageCursor
	return r
}

// Number of results to return.  Default is 100 items. Maximum is 1000 items.
func (r ApiListStablecoinConversionsRequest) Limit(limit int32) ApiListStablecoinConversionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListStablecoinConversionsRequest) Execute() (*ListStablecoinConversionsResponse, *http.Response, error) {
	return r.ApiService.ListStablecoinConversionsExecute(r)
}

/*
ListStablecoinConversions List Stablecoin Conversions

List all conversions, optionally filtering and paging the results.

By default, conversions are returned in reverse chronological (descending)
order by creation time. If no query parameters are supplied,
the response will include up to the last 100 conversions which
were created.

The paginated results default to display up to 100 conversions, unless
otherwise specified with the `limit` parameter. The maximum `limit` value is 1000.
Every paginated response contains a `next_page_cursor` field until the last page is reached.

Pass the `next_page_cursor` value into the `page_cursor` field of a new
request to retrieve the next page of results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListStablecoinConversionsRequest
*/
func (a *StablecoinConversionAPIService) ListStablecoinConversions(ctx context.Context) ApiListStablecoinConversionsRequest {
	return ApiListStablecoinConversionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListStablecoinConversionsResponse
func (a *StablecoinConversionAPIService) ListStablecoinConversionsExecute(r ApiListStablecoinConversionsRequest) (*ListStablecoinConversionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListStablecoinConversionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "StablecoinConversionAPIService.ListStablecoinConversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/conversion/stablecoins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", r.profileId, "form", "")
	}
	if r.refId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ref_id", r.refId, "form", "")
	}
	if r.createdAtBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.begin", r.createdAtBegin, "form", "")
	}
	if r.createdAtEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.end", r.createdAtEnd, "form", "")
	}
	if r.updatedAtBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.begin", r.updatedAtBegin, "form", "")
	}
	if r.updatedAtEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.end", r.updatedAtEnd, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
