/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// MonitoringAddressesAPIService MonitoringAddressesAPI service
type MonitoringAddressesAPIService service

type ApiCreateMonitoringAddressRequest struct {
	ctx context.Context
	ApiService *MonitoringAddressesAPIService
	createMonitoringAddressRequest *CreateMonitoringAddressRequest
}

func (r ApiCreateMonitoringAddressRequest) CreateMonitoringAddressRequest(createMonitoringAddressRequest CreateMonitoringAddressRequest) ApiCreateMonitoringAddressRequest {
	r.createMonitoringAddressRequest = &createMonitoringAddressRequest
	return r
}

func (r ApiCreateMonitoringAddressRequest) Execute() (*CreateMonitoringAddressResponse, *http.Response, error) {
	return r.ApiService.CreateMonitoringAddressExecute(r)
}

/*
CreateMonitoringAddress Create Monitoring Address

Adds an address to be monitored for rewards tracking.

Currently only `ETHEREUM`, `SOLANA`, `INK` & `XLAYER` addresses are supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateMonitoringAddressRequest
*/
func (a *MonitoringAddressesAPIService) CreateMonitoringAddress(ctx context.Context) ApiCreateMonitoringAddressRequest {
	return ApiCreateMonitoringAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateMonitoringAddressResponse
func (a *MonitoringAddressesAPIService) CreateMonitoringAddressExecute(r ApiCreateMonitoringAddressRequest) (*CreateMonitoringAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateMonitoringAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAddressesAPIService.CreateMonitoringAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rewards/monitor/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createMonitoringAddressRequest == nil {
		return localVarReturnValue, nil, reportError("createMonitoringAddressRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createMonitoringAddressRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMonitoringAddressRequest struct {
	ctx context.Context
	ApiService *MonitoringAddressesAPIService
	id string
}

func (r ApiGetMonitoringAddressRequest) Execute() (*GetMonitoringAddressResponse, *http.Response, error) {
	return r.ApiService.GetMonitoringAddressExecute(r)
}

/*
GetMonitoringAddress Get Monitoring Address

Retrieves a monitoring address by ID

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id UUID direct reference to a particular monitored address.
 @return ApiGetMonitoringAddressRequest
*/
func (a *MonitoringAddressesAPIService) GetMonitoringAddress(ctx context.Context, id string) ApiGetMonitoringAddressRequest {
	return ApiGetMonitoringAddressRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetMonitoringAddressResponse
func (a *MonitoringAddressesAPIService) GetMonitoringAddressExecute(r ApiGetMonitoringAddressRequest) (*GetMonitoringAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetMonitoringAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAddressesAPIService.GetMonitoringAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rewards/monitor/address/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMonitoringAddressRequest struct {
	ctx context.Context
	ApiService *MonitoringAddressesAPIService
	address *string
	cryptoNetwork *string
	limit *int32
	order *string
	pageCursor *string
}

// On-chain address Paxos is monitoring for eligible reward activity. Must be valid for the specified network. For &#x60;SOLANA&#x60; specify the wallet account (ie: not a derived/token account like an ATA).
func (r ApiListMonitoringAddressRequest) Address(address string) ApiListMonitoringAddressRequest {
	r.address = &address
	return r
}

// Network the address belongs to. Supported: &#x60;ETHEREUM&#x60;, &#x60;SOLANA&#x60;, &#x60;INK&#x60;, &#x60;XLAYER&#x60;.
func (r ApiListMonitoringAddressRequest) CryptoNetwork(cryptoNetwork string) ApiListMonitoringAddressRequest {
	r.cryptoNetwork = &cryptoNetwork
	return r
}

// Number of results to return. Defaults to &#x60;100&#x60; if no limit is provided. Maximum &#x60;1000&#x60;.
func (r ApiListMonitoringAddressRequest) Limit(limit int32) ApiListMonitoringAddressRequest {
	r.limit = &limit
	return r
}

// Results are ordered by &#x60;created_at&#x60;. Specify the ordering of the results. Defaults to &#x60;DESC&#x60;.
func (r ApiListMonitoringAddressRequest) Order(order string) ApiListMonitoringAddressRequest {
	r.order = &order
	return r
}

// Cursor for pagination
func (r ApiListMonitoringAddressRequest) PageCursor(pageCursor string) ApiListMonitoringAddressRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiListMonitoringAddressRequest) Execute() (*ListMonitoringAddressResponse, *http.Response, error) {
	return r.ApiService.ListMonitoringAddressExecute(r)
}

/*
ListMonitoringAddress List Monitoring Address

Retrieve a list of monitoring address

Filter by network to retrieve a list of addresses on that network, or filter by network & address to retrieve a single record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListMonitoringAddressRequest
*/
func (a *MonitoringAddressesAPIService) ListMonitoringAddress(ctx context.Context) ApiListMonitoringAddressRequest {
	return ApiListMonitoringAddressRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListMonitoringAddressResponse
func (a *MonitoringAddressesAPIService) ListMonitoringAddressExecute(r ApiListMonitoringAddressRequest) (*ListMonitoringAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListMonitoringAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAddressesAPIService.ListMonitoringAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rewards/monitor/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.address != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "address", r.address, "")
	}
	if r.cryptoNetwork != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "crypto_network", r.cryptoNetwork, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMonitoringAddressRequest struct {
	ctx context.Context
	ApiService *MonitoringAddressesAPIService
	id string
	autoRewardsPublicUpdateMonitoringAddressBody *AutoRewardsPublicUpdateMonitoringAddressBody
}

func (r ApiUpdateMonitoringAddressRequest) AutoRewardsPublicUpdateMonitoringAddressBody(autoRewardsPublicUpdateMonitoringAddressBody AutoRewardsPublicUpdateMonitoringAddressBody) ApiUpdateMonitoringAddressRequest {
	r.autoRewardsPublicUpdateMonitoringAddressBody = &autoRewardsPublicUpdateMonitoringAddressBody
	return r
}

func (r ApiUpdateMonitoringAddressRequest) Execute() (*UpdateMonitoringAddressResponse, *http.Response, error) {
	return r.ApiService.UpdateMonitoringAddressExecute(r)
}

/*
UpdateMonitoringAddress Update Monitoring Address

Updates a monitored address name

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id UUID direct reference to a particular monitored address.
 @return ApiUpdateMonitoringAddressRequest
*/
func (a *MonitoringAddressesAPIService) UpdateMonitoringAddress(ctx context.Context, id string) ApiUpdateMonitoringAddressRequest {
	return ApiUpdateMonitoringAddressRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return UpdateMonitoringAddressResponse
func (a *MonitoringAddressesAPIService) UpdateMonitoringAddressExecute(r ApiUpdateMonitoringAddressRequest) (*UpdateMonitoringAddressResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateMonitoringAddressResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MonitoringAddressesAPIService.UpdateMonitoringAddress")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/rewards/monitor/address/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.autoRewardsPublicUpdateMonitoringAddressBody == nil {
		return localVarReturnValue, nil, reportError("autoRewardsPublicUpdateMonitoringAddressBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.autoRewardsPublicUpdateMonitoringAddressBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
