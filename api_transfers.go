/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// TransfersAPIService TransfersAPI service
type TransfersAPIService service

type ApiGetTransferRequest struct {
	ctx context.Context
	ApiService *TransfersAPIService
	id string
}

func (r ApiGetTransferRequest) Execute() (*Transfer, *http.Response, error) {
	return r.ApiService.GetTransferExecute(r)
}

/*
GetTransfer Get Transfer

Get a single transfer by ID.

In the polling workflow, this endpoint can be called to monitor transfer
status changes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The Paxos transfer UUID.
 @return ApiGetTransferRequest
*/
func (a *TransfersAPIService) GetTransfer(ctx context.Context, id string) ApiGetTransferRequest {
	return ApiGetTransferRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Transfer
func (a *TransfersAPIService) GetTransferExecute(r ApiGetTransferRequest) (*Transfer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Transfer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransfersAPIService.GetTransfer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transfer/transfers/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTransfersRequest struct {
	ctx context.Context
	ApiService *TransfersAPIService
	profileIds *[]string
	identityIds *[]string
	refIds *[]string
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtEq *time.Time
	createdAtGte *time.Time
	createdAtGt *time.Time
	updatedAtLt *time.Time
	updatedAtLte *time.Time
	updatedAtEq *time.Time
	updatedAtGte *time.Time
	updatedAtGt *time.Time
	limit *int32
	order *string
	orderBy *string
	pageCursor *string
	accountIds *[]string
	ids *[]string
	type_ *[]string
	groupIds *[]string
	cryptoTxHashes *[]string
	secondaryStatuses *[]string
	statuses *[]string
}

// Optionally filter by the target profiles of the transfers. Limit 100. Can be combined with created_at.* or updated_at.* filtering options only.
func (r ApiListTransfersRequest) ProfileIds(profileIds []string) ApiListTransfersRequest {
	r.profileIds = &profileIds
	return r
}

// Optionally filter by the Identities associated with the transfers. Limit 100. Can be combined with created_at.* or updated_at.* filtering options only.
func (r ApiListTransfersRequest) IdentityIds(identityIds []string) ApiListTransfersRequest {
	r.identityIds = &identityIds
	return r
}

// The client-specified IDs provided during transfer creation. Limit 100. Can be combined with created_at.* or updated_at.* filtering options only.
func (r ApiListTransfersRequest) RefIds(refIds []string) ApiListTransfersRequest {
	r.refIds = &refIds
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) CreatedAtLt(createdAtLt time.Time) ApiListTransfersRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) CreatedAtLte(createdAtLte time.Time) ApiListTransfersRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) CreatedAtEq(createdAtEq time.Time) ApiListTransfersRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) CreatedAtGte(createdAtGte time.Time) ApiListTransfersRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) CreatedAtGt(createdAtGt time.Time) ApiListTransfersRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) UpdatedAtLt(updatedAtLt time.Time) ApiListTransfersRequest {
	r.updatedAtLt = &updatedAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) UpdatedAtLte(updatedAtLte time.Time) ApiListTransfersRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) UpdatedAtEq(updatedAtEq time.Time) ApiListTransfersRequest {
	r.updatedAtEq = &updatedAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) UpdatedAtGte(updatedAtGte time.Time) ApiListTransfersRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTransfersRequest) UpdatedAtGt(updatedAtGt time.Time) ApiListTransfersRequest {
	r.updatedAtGt = &updatedAtGt
	return r
}

// Number of results to return. Defaults to 100 if no limit is provided. Maximum 1000.
func (r ApiListTransfersRequest) Limit(limit int32) ApiListTransfersRequest {
	r.limit = &limit
	return r
}

// Determines whether the items are returned in ascending (ASC), or descending (DESC) order. Defaults to ASC if &#x60;order_by&#x60; is UPDATED_AT. Otherwise defaults to DESC.
func (r ApiListTransfersRequest) Order(order string) ApiListTransfersRequest {
	r.order = &order
	return r
}

// The specific method by which the returned results will be ordered. When specifying both &#x60;order_by&#x60; and a timestamp filter, &#x60;order_by&#x60; must equal the timestamp filter type. For example:  &#x60;updated_at.gte &#x3D; 2022-07-01T03:02:01Z&#x60;, &#x60;order_by &#x3D; UPDATED_AT&#x60;  Using &#x60;updated_at.gte &#x3D; 2022-07-01T03:02:01Z&#x60;, &#x60;order_by &#x3D; CREATED_AT&#x60; is an invalid pairing.
func (r ApiListTransfersRequest) OrderBy(orderBy string) ApiListTransfersRequest {
	r.orderBy = &orderBy
	return r
}

// Optional: Cursor for getting the next page of results. When the number of items returned is fewer than the limit, there is currently no next page.
func (r ApiListTransfersRequest) PageCursor(pageCursor string) ApiListTransfersRequest {
	r.pageCursor = &pageCursor
	return r
}

// Optionally filter by the Accounts associated with the transfers. Limit 100. Can be combined with created_at.* or updated_at.* filtering options only.
func (r ApiListTransfersRequest) AccountIds(accountIds []string) ApiListTransfersRequest {
	r.accountIds = &accountIds
	return r
}

// Optionally filter by the transfer ids. Limit 100. Can be combined with created_at.* or updated_at.* filtering options only.
func (r ApiListTransfersRequest) Ids(ids []string) ApiListTransfersRequest {
	r.ids = &ids
	return r
}

// Retrieve all (default) or the specified transfers. Optionally filter by transfer &#x60;type&#x60;. To retrieve multiple transfer types, use query parameters: e.g., &#x60;type&#x3D;CRYPTO_DEPOSIT&amp;type&#x3D;CRYPTO_WITHDRAWAL&#x60;. Can be combined with &#x60;created_at.*&#x60; or &#x60;updated_at.*&#x60; filtering options only.
func (r ApiListTransfersRequest) Type_(type_ []string) ApiListTransfersRequest {
	r.type_ = &type_
	return r
}

// Optionally filter by transfer &#x60;group_ids&#x60;. Limit 100.
func (r ApiListTransfersRequest) GroupIds(groupIds []string) ApiListTransfersRequest {
	r.groupIds = &groupIds
	return r
}

// Optionally filter by the on-chain transaction hash for crypto transactions. Limit 100.
func (r ApiListTransfersRequest) CryptoTxHashes(cryptoTxHashes []string) ApiListTransfersRequest {
	r.cryptoTxHashes = &cryptoTxHashes
	return r
}

// Optionally filter by secondary status.   - TRAVEL_RULE_INFO_REQUESTED: Travel rule information is required to continue processing the transfer.  - TRAVEL_RULE_REJECTED: Transfer has been terminally rejected due to failing travel rule checks.
func (r ApiListTransfersRequest) SecondaryStatuses(secondaryStatuses []string) ApiListTransfersRequest {
	r.secondaryStatuses = &secondaryStatuses
	return r
}

// Optionally filter by status.
func (r ApiListTransfersRequest) Statuses(statuses []string) ApiListTransfersRequest {
	r.statuses = &statuses
	return r
}

func (r ApiListTransfersRequest) Execute() (*ListTransfersResponse, *http.Response, error) {
	return r.ApiService.ListTransfersExecute(r)
}

/*
ListTransfers List Transfers

List all transfers, optionally filtering and paging the results.

By default, transfers are returned in reverse chronological (descending)
order by creation time.

The recommended polling workflow is to query the results in ascending
order (by setting `order_by` to `CREATED_AT`), keeping track of the
`created_at` timestamp of the most recent transfer in the paged results.
Once transfers are discovered, the caller should store the returned `ID`
and query GetTransfer to retrieve status updates.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTransfersRequest
*/
func (a *TransfersAPIService) ListTransfers(ctx context.Context) ApiListTransfersRequest {
	return ApiListTransfersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTransfersResponse
func (a *TransfersAPIService) ListTransfersExecute(r ApiListTransfersRequest) (*ListTransfersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTransfersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransfersAPIService.ListTransfers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/transfer/transfers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profile_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profile_ids", t, "multi")
		}
	}
	if r.identityIds != nil {
		t := *r.identityIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "identity_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "identity_ids", t, "multi")
		}
	}
	if r.refIds != nil {
		t := *r.refIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ref_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ref_ids", t, "multi")
		}
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lt", r.createdAtLt, "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lte", r.createdAtLte, "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.eq", r.createdAtEq, "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gte", r.createdAtGte, "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gt", r.createdAtGt, "")
	}
	if r.updatedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lt", r.updatedAtLt, "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lte", r.updatedAtLte, "")
	}
	if r.updatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.eq", r.updatedAtEq, "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gte", r.updatedAtGte, "")
	}
	if r.updatedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gt", r.updatedAtGt, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "multi")
		}
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.type_ != nil {
		t := *r.type_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "type", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "type", t, "multi")
		}
	}
	if r.groupIds != nil {
		t := *r.groupIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "group_ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "group_ids", t, "multi")
		}
	}
	if r.cryptoTxHashes != nil {
		t := *r.cryptoTxHashes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "crypto_tx_hashes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "crypto_tx_hashes", t, "multi")
		}
	}
	if r.secondaryStatuses != nil {
		t := *r.secondaryStatuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "secondary_statuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "secondary_statuses", t, "multi")
		}
	}
	if r.statuses != nil {
		t := *r.statuses
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "statuses", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
