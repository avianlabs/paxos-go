/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"encoding/json"
)

// checks if the TransferLimit type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &TransferLimit{}

// TransferLimit struct for TransferLimit
type TransferLimit struct {
	// The ID of the limit. Single-transaction limits will not have an id, but only a rule id.
	Id *string `json:"id,omitempty"`
	// The limit rule this limit applies to.
	RuleId *string `json:"rule_id,omitempty"`
	// One or more transfer types that the limit applies to, ordered alphabetically.
	TransferTypes []TransferType `json:"transfer_types,omitempty"`
	// The number of seconds that the limit is measured over. Single-transaction limits have period 0.
	PeriodSeconds *string `json:"period_seconds,omitempty"`
	// The limit.
	Limit *string `json:"limit,omitempty"`
	// The limit, minus any transactions that have been done in the period. Single-transaction limits always have remaining set to the limit.
	Remaining *string `json:"remaining,omitempty"`
	// The asset that limit and remaining are given in, e.g. \"USD\", \"BTC\", \"ETH\".
	LimitAsset *string `json:"limit_asset,omitempty"`
	AdditionalProperties map[string]interface{}
}

type _TransferLimit TransferLimit

// NewTransferLimit instantiates a new TransferLimit object
// This constructor will assign default values to properties that have it defined,
// and makes sure properties required by API are set, but the set of arguments
// will change when the set of required properties is changed
func NewTransferLimit() *TransferLimit {
	this := TransferLimit{}
	return &this
}

// NewTransferLimitWithDefaults instantiates a new TransferLimit object
// This constructor will only assign default values to properties that have it defined,
// but it doesn't guarantee that properties required by API are set
func NewTransferLimitWithDefaults() *TransferLimit {
	this := TransferLimit{}
	return &this
}

// GetId returns the Id field value if set, zero value otherwise.
func (o *TransferLimit) GetId() string {
	if o == nil || IsNil(o.Id) {
		var ret string
		return ret
	}
	return *o.Id
}

// GetIdOk returns a tuple with the Id field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetIdOk() (*string, bool) {
	if o == nil || IsNil(o.Id) {
		return nil, false
	}
	return o.Id, true
}

// HasId returns a boolean if a field has been set.
func (o *TransferLimit) HasId() bool {
	if o != nil && !IsNil(o.Id) {
		return true
	}

	return false
}

// SetId gets a reference to the given string and assigns it to the Id field.
func (o *TransferLimit) SetId(v string) {
	o.Id = &v
}

// GetRuleId returns the RuleId field value if set, zero value otherwise.
func (o *TransferLimit) GetRuleId() string {
	if o == nil || IsNil(o.RuleId) {
		var ret string
		return ret
	}
	return *o.RuleId
}

// GetRuleIdOk returns a tuple with the RuleId field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetRuleIdOk() (*string, bool) {
	if o == nil || IsNil(o.RuleId) {
		return nil, false
	}
	return o.RuleId, true
}

// HasRuleId returns a boolean if a field has been set.
func (o *TransferLimit) HasRuleId() bool {
	if o != nil && !IsNil(o.RuleId) {
		return true
	}

	return false
}

// SetRuleId gets a reference to the given string and assigns it to the RuleId field.
func (o *TransferLimit) SetRuleId(v string) {
	o.RuleId = &v
}

// GetTransferTypes returns the TransferTypes field value if set, zero value otherwise.
func (o *TransferLimit) GetTransferTypes() []TransferType {
	if o == nil || IsNil(o.TransferTypes) {
		var ret []TransferType
		return ret
	}
	return o.TransferTypes
}

// GetTransferTypesOk returns a tuple with the TransferTypes field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetTransferTypesOk() ([]TransferType, bool) {
	if o == nil || IsNil(o.TransferTypes) {
		return nil, false
	}
	return o.TransferTypes, true
}

// HasTransferTypes returns a boolean if a field has been set.
func (o *TransferLimit) HasTransferTypes() bool {
	if o != nil && !IsNil(o.TransferTypes) {
		return true
	}

	return false
}

// SetTransferTypes gets a reference to the given []TransferType and assigns it to the TransferTypes field.
func (o *TransferLimit) SetTransferTypes(v []TransferType) {
	o.TransferTypes = v
}

// GetPeriodSeconds returns the PeriodSeconds field value if set, zero value otherwise.
func (o *TransferLimit) GetPeriodSeconds() string {
	if o == nil || IsNil(o.PeriodSeconds) {
		var ret string
		return ret
	}
	return *o.PeriodSeconds
}

// GetPeriodSecondsOk returns a tuple with the PeriodSeconds field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetPeriodSecondsOk() (*string, bool) {
	if o == nil || IsNil(o.PeriodSeconds) {
		return nil, false
	}
	return o.PeriodSeconds, true
}

// HasPeriodSeconds returns a boolean if a field has been set.
func (o *TransferLimit) HasPeriodSeconds() bool {
	if o != nil && !IsNil(o.PeriodSeconds) {
		return true
	}

	return false
}

// SetPeriodSeconds gets a reference to the given string and assigns it to the PeriodSeconds field.
func (o *TransferLimit) SetPeriodSeconds(v string) {
	o.PeriodSeconds = &v
}

// GetLimit returns the Limit field value if set, zero value otherwise.
func (o *TransferLimit) GetLimit() string {
	if o == nil || IsNil(o.Limit) {
		var ret string
		return ret
	}
	return *o.Limit
}

// GetLimitOk returns a tuple with the Limit field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetLimitOk() (*string, bool) {
	if o == nil || IsNil(o.Limit) {
		return nil, false
	}
	return o.Limit, true
}

// HasLimit returns a boolean if a field has been set.
func (o *TransferLimit) HasLimit() bool {
	if o != nil && !IsNil(o.Limit) {
		return true
	}

	return false
}

// SetLimit gets a reference to the given string and assigns it to the Limit field.
func (o *TransferLimit) SetLimit(v string) {
	o.Limit = &v
}

// GetRemaining returns the Remaining field value if set, zero value otherwise.
func (o *TransferLimit) GetRemaining() string {
	if o == nil || IsNil(o.Remaining) {
		var ret string
		return ret
	}
	return *o.Remaining
}

// GetRemainingOk returns a tuple with the Remaining field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetRemainingOk() (*string, bool) {
	if o == nil || IsNil(o.Remaining) {
		return nil, false
	}
	return o.Remaining, true
}

// HasRemaining returns a boolean if a field has been set.
func (o *TransferLimit) HasRemaining() bool {
	if o != nil && !IsNil(o.Remaining) {
		return true
	}

	return false
}

// SetRemaining gets a reference to the given string and assigns it to the Remaining field.
func (o *TransferLimit) SetRemaining(v string) {
	o.Remaining = &v
}

// GetLimitAsset returns the LimitAsset field value if set, zero value otherwise.
func (o *TransferLimit) GetLimitAsset() string {
	if o == nil || IsNil(o.LimitAsset) {
		var ret string
		return ret
	}
	return *o.LimitAsset
}

// GetLimitAssetOk returns a tuple with the LimitAsset field value if set, nil otherwise
// and a boolean to check if the value has been set.
func (o *TransferLimit) GetLimitAssetOk() (*string, bool) {
	if o == nil || IsNil(o.LimitAsset) {
		return nil, false
	}
	return o.LimitAsset, true
}

// HasLimitAsset returns a boolean if a field has been set.
func (o *TransferLimit) HasLimitAsset() bool {
	if o != nil && !IsNil(o.LimitAsset) {
		return true
	}

	return false
}

// SetLimitAsset gets a reference to the given string and assigns it to the LimitAsset field.
func (o *TransferLimit) SetLimitAsset(v string) {
	o.LimitAsset = &v
}

func (o TransferLimit) MarshalJSON() ([]byte, error) {
	toSerialize,err := o.ToMap()
	if err != nil {
		return []byte{}, err
	}
	return json.Marshal(toSerialize)
}

func (o TransferLimit) ToMap() (map[string]interface{}, error) {
	toSerialize := map[string]interface{}{}
	if !IsNil(o.Id) {
		toSerialize["id"] = o.Id
	}
	if !IsNil(o.RuleId) {
		toSerialize["rule_id"] = o.RuleId
	}
	if !IsNil(o.TransferTypes) {
		toSerialize["transfer_types"] = o.TransferTypes
	}
	if !IsNil(o.PeriodSeconds) {
		toSerialize["period_seconds"] = o.PeriodSeconds
	}
	if !IsNil(o.Limit) {
		toSerialize["limit"] = o.Limit
	}
	if !IsNil(o.Remaining) {
		toSerialize["remaining"] = o.Remaining
	}
	if !IsNil(o.LimitAsset) {
		toSerialize["limit_asset"] = o.LimitAsset
	}

	for key, value := range o.AdditionalProperties {
		toSerialize[key] = value
	}

	return toSerialize, nil
}

func (o *TransferLimit) UnmarshalJSON(data []byte) (err error) {
	varTransferLimit := _TransferLimit{}

	err = json.Unmarshal(data, &varTransferLimit)

	if err != nil {
		return err
	}

	*o = TransferLimit(varTransferLimit)

	additionalProperties := make(map[string]interface{})

	if err = json.Unmarshal(data, &additionalProperties); err == nil {
		delete(additionalProperties, "id")
		delete(additionalProperties, "rule_id")
		delete(additionalProperties, "transfer_types")
		delete(additionalProperties, "period_seconds")
		delete(additionalProperties, "limit")
		delete(additionalProperties, "remaining")
		delete(additionalProperties, "limit_asset")
		o.AdditionalProperties = additionalProperties
	}

	return err
}

type NullableTransferLimit struct {
	value *TransferLimit
	isSet bool
}

func (v NullableTransferLimit) Get() *TransferLimit {
	return v.value
}

func (v *NullableTransferLimit) Set(val *TransferLimit) {
	v.value = val
	v.isSet = true
}

func (v NullableTransferLimit) IsSet() bool {
	return v.isSet
}

func (v *NullableTransferLimit) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableTransferLimit(val *TransferLimit) *NullableTransferLimit {
	return &NullableTransferLimit{value: val, isSet: true}
}

func (v NullableTransferLimit) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableTransferLimit) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


