/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// OrchestrationsAPIService OrchestrationsAPI service
type OrchestrationsAPIService service

type ApiCreateOrchestrationRequest struct {
	ctx context.Context
	ApiService *OrchestrationsAPIService
	createOrchestrationRequest *CreateOrchestrationRequest
}

func (r ApiCreateOrchestrationRequest) CreateOrchestrationRequest(createOrchestrationRequest CreateOrchestrationRequest) ApiCreateOrchestrationRequest {
	r.createOrchestrationRequest = &createOrchestrationRequest
	return r
}

func (r ApiCreateOrchestrationRequest) Execute() (*Orchestration, *http.Response, error) {
	return r.ApiService.CreateOrchestrationExecute(r)
}

/*
CreateOrchestration Create Orchestration

Creates a one-time orchestration that moves assets from a source profile to a destination.
Use this endpoint when funds already reside on the Paxos platform and need to be transferred or converted as part of a single workflow.

A request to create an orchestration can fail with one of the following
types of errors:
 - [Insufficient Funds](https://developer.paxos.com/docs/v2/problems/insufficient-funds)
   if the Profile (`profile_id`) has insufficient available balance to
   fund the execution.
 - [Already Exists](https://developer.paxos.com/docs/v2/problems/already-exists)
   if an orchestration with the same external ID (`ref_id`) has already been created.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrchestrationRequest
*/
func (a *OrchestrationsAPIService) CreateOrchestration(ctx context.Context) ApiCreateOrchestrationRequest {
	return ApiCreateOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Orchestration
func (a *OrchestrationsAPIService) CreateOrchestrationExecute(r ApiCreateOrchestrationRequest) (*Orchestration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Orchestration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestrationsAPIService.CreateOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orchestration/orchestrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrchestrationRequest == nil {
		return localVarReturnValue, nil, reportError("createOrchestrationRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrchestrationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrchestrationRequest struct {
	ctx context.Context
	ApiService *OrchestrationsAPIService
	id string
}

func (r ApiGetOrchestrationRequest) Execute() (*Orchestration, *http.Response, error) {
	return r.ApiService.GetOrchestrationExecute(r)
}

/*
GetOrchestration Get Orchestration

Retreives a specific orchestration using its orchestration ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetOrchestrationRequest
*/
func (a *OrchestrationsAPIService) GetOrchestration(ctx context.Context, id string) ApiGetOrchestrationRequest {
	return ApiGetOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Orchestration
func (a *OrchestrationsAPIService) GetOrchestrationExecute(r ApiGetOrchestrationRequest) (*Orchestration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Orchestration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestrationsAPIService.GetOrchestration")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orchestration/orchestrations/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrchestrationsRequest struct {
	ctx context.Context
	ApiService *OrchestrationsAPIService
	orchestrationRuleId *[]string
	sourceAsset *[]string
	destinationAsset *[]string
	status *[]string
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtEq *time.Time
	createdAtGte *time.Time
	createdAtGt *time.Time
	limit *int32
	order *string
	pageCursor *string
	orchestrationId *[]string
	profileId *[]string
}

// Optionally filter by the initiating orchestration rule ids. There is a limit of 100 orchestration rule ids that can be specified in a single request.
func (r ApiListOrchestrationsRequest) OrchestrationRuleId(orchestrationRuleId []string) ApiListOrchestrationsRequest {
	r.orchestrationRuleId = &orchestrationRuleId
	return r
}

// Optionally filter by source assets. There is a limit of 100 source assets that can be specified in a single request.
func (r ApiListOrchestrationsRequest) SourceAsset(sourceAsset []string) ApiListOrchestrationsRequest {
	r.sourceAsset = &sourceAsset
	return r
}

// Optionally filter by destination assets. There is a limit of 100 destination assets ids that can be specified in a single request.
func (r ApiListOrchestrationsRequest) DestinationAsset(destinationAsset []string) ApiListOrchestrationsRequest {
	r.destinationAsset = &destinationAsset
	return r
}

// Optionally filter by statuses. There is a limit of 100 statuses that can be specified in a single request.
func (r ApiListOrchestrationsRequest) Status(status []string) ApiListOrchestrationsRequest {
	r.status = &status
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrchestrationsRequest) CreatedAtLt(createdAtLt time.Time) ApiListOrchestrationsRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrchestrationsRequest) CreatedAtLte(createdAtLte time.Time) ApiListOrchestrationsRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrchestrationsRequest) CreatedAtEq(createdAtEq time.Time) ApiListOrchestrationsRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrchestrationsRequest) CreatedAtGte(createdAtGte time.Time) ApiListOrchestrationsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListOrchestrationsRequest) CreatedAtGt(createdAtGt time.Time) ApiListOrchestrationsRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Number of results to return. Defaults to 100 if no limit is provided. Maximum 1000.
func (r ApiListOrchestrationsRequest) Limit(limit int32) ApiListOrchestrationsRequest {
	r.limit = &limit
	return r
}

// Sort order for the results. Defaults to DESC by created_at time.
func (r ApiListOrchestrationsRequest) Order(order string) ApiListOrchestrationsRequest {
	r.order = &order
	return r
}

// Optional Cursor for getting the next page of results.
func (r ApiListOrchestrationsRequest) PageCursor(pageCursor string) ApiListOrchestrationsRequest {
	r.pageCursor = &pageCursor
	return r
}

// Optionally filter by a list of orchestration IDs. There is a limit of 100 orchestration ids that can be specified in a single request.
func (r ApiListOrchestrationsRequest) OrchestrationId(orchestrationId []string) ApiListOrchestrationsRequest {
	r.orchestrationId = &orchestrationId
	return r
}

// Optionally filter by the target profiles. There is a limit of 100 profiles that can be specified in a single request.
func (r ApiListOrchestrationsRequest) ProfileId(profileId []string) ApiListOrchestrationsRequest {
	r.profileId = &profileId
	return r
}

func (r ApiListOrchestrationsRequest) Execute() (*ListOrchestrationsResponse, *http.Response, error) {
	return r.ApiService.ListOrchestrationsExecute(r)
}

/*
ListOrchestrations List Orchestrations

List all orchestrations, optionally filtering and paging the results.

By default, orchestrations are returned in reverse chronological (descending)
order by creation time. If no query parameters are supplied,
the response will include up to the last 100 orchestrations which
were created.

The paginated results default to display up to 100 orchestrations, unless
otherwise specified with the `limit` parameter. The maximum `limit` value is 1000.
Every paginated response contains a `next_page_cursor` field until the last page is reached.

Pass the `next_page_cursor` value into the `page_cursor` field of a new
request to retrieve the next page of results.

When filtering by profile IDs using the `profile_ids` parameter, there is a limit of 100 profiles
that can be specified in a single request.

Orchestrations are provided for various operations including:
- Deposits to a paxos-platform crypto address or bank account
- Withdrawals to a customer-owned crypto address or bank account
- Conversions from one asset to another
- Orchestrated workflows involving some or all of the above
- Invocation of an Orchestration Rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOrchestrationsRequest
*/
func (a *OrchestrationsAPIService) ListOrchestrations(ctx context.Context) ApiListOrchestrationsRequest {
	return ApiListOrchestrationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListOrchestrationsResponse
func (a *OrchestrationsAPIService) ListOrchestrationsExecute(r ApiListOrchestrationsRequest) (*ListOrchestrationsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListOrchestrationsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrchestrationsAPIService.ListOrchestrations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/orchestration/orchestrations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orchestrationRuleId != nil {
		t := *r.orchestrationRuleId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orchestration_rule_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orchestration_rule_id", t, "multi")
		}
	}
	if r.sourceAsset != nil {
		t := *r.sourceAsset
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "source_asset", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "source_asset", t, "multi")
		}
	}
	if r.destinationAsset != nil {
		t := *r.destinationAsset
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "destination_asset", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "destination_asset", t, "multi")
		}
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lt", r.createdAtLt, "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lte", r.createdAtLte, "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.eq", r.createdAtEq, "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gte", r.createdAtGte, "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gt", r.createdAtGt, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.orchestrationId != nil {
		t := *r.orchestrationId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "orchestration_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "orchestration_id", t, "multi")
		}
	}
	if r.profileId != nil {
		t := *r.profileId
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
