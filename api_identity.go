/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// IdentityAPIService IdentityAPI service
type IdentityAPIService service

type ApiCreateIdentityRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	createIdentityRequest *CreateIdentityRequest
}

func (r ApiCreateIdentityRequest) CreateIdentityRequest(createIdentityRequest CreateIdentityRequest) ApiCreateIdentityRequest {
	r.createIdentityRequest = &createIdentityRequest
	return r
}

func (r ApiCreateIdentityRequest) Execute() (*Identity, *http.Response, error) {
	return r.ApiService.CreateIdentityExecute(r)
}

/*
CreateIdentity Create Identity

Creates a new Person or Institution Identity on the Paxos Platform.

A successful response indicates that the identity has been created and is `PENDING` approval. The identity is only
available to use on the Platform once it is `APPROVED`. For a full description of statuses read the [status guide here](https://docs.paxos.com/identity/statuses).

For detailed guidance on which [fields are required](https://docs.paxos.com/identity/required-details) for your integration
or the [lifecycle of an Identity](https://docs.paxos.com/identity/statuses) on the platform, please read the [Identity Developer Guide](https://docs.paxos.com/identity).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIdentityRequest
*/
func (a *IdentityAPIService) CreateIdentity(ctx context.Context) ApiCreateIdentityRequest {
	return ApiCreateIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Identity
func (a *IdentityAPIService) CreateIdentityExecute(r ApiCreateIdentityRequest) (*Identity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Identity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.CreateIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIdentityRequest == nil {
		return localVarReturnValue, nil, reportError("createIdentityRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIdentityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIdentityRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	id string
	includeDetails *bool
	includeInstitutionMembers *bool
}

// query param; details are encrypted, so we do not want to include them by default
func (r ApiGetIdentityRequest) IncludeDetails(includeDetails bool) ApiGetIdentityRequest {
	r.includeDetails = &includeDetails
	return r
}

// query param; to include institution members for institution identity
func (r ApiGetIdentityRequest) IncludeInstitutionMembers(includeInstitutionMembers bool) ApiGetIdentityRequest {
	r.includeInstitutionMembers = &includeInstitutionMembers
	return r
}

func (r ApiGetIdentityRequest) Execute() (*Identity, *http.Response, error) {
	return r.ApiService.GetIdentityExecute(r)
}

/*
GetIdentity Get Identity

Get an Identity by its (identity) id. You can only see identities created by you.

You can use the query parameter `include_details` to include identity details (`person_details` or `institution_details`) in
the response and the query parameter `include_institution_members` to include institution members in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id associated with the identity
 @return ApiGetIdentityRequest
*/
func (a *IdentityAPIService) GetIdentity(ctx context.Context, id string) ApiGetIdentityRequest {
	return ApiGetIdentityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Identity
func (a *IdentityAPIService) GetIdentityExecute(r ApiGetIdentityRequest) (*Identity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Identity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.GetIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_details", r.includeDetails, "")
	}
	if r.includeInstitutionMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_institution_members", r.includeInstitutionMembers, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIdentitiesRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	summaryStatus *string
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtEq *time.Time
	createdAtGte *time.Time
	createdAtGt *time.Time
	updatedAtLt *time.Time
	updatedAtLte *time.Time
	updatedAtEq *time.Time
	updatedAtGte *time.Time
	updatedAtGt *time.Time
	limit *int32
	order *string
	orderBy *string
	pageCursor *string
	identityType *string
}

// Summary Status of the Identity.
func (r ApiListIdentitiesRequest) SummaryStatus(summaryStatus string) ApiListIdentitiesRequest {
	r.summaryStatus = &summaryStatus
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtLt(createdAtLt time.Time) ApiListIdentitiesRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtLte(createdAtLte time.Time) ApiListIdentitiesRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtEq(createdAtEq time.Time) ApiListIdentitiesRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtGte(createdAtGte time.Time) ApiListIdentitiesRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtGt(createdAtGt time.Time) ApiListIdentitiesRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtLt(updatedAtLt time.Time) ApiListIdentitiesRequest {
	r.updatedAtLt = &updatedAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtLte(updatedAtLte time.Time) ApiListIdentitiesRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtEq(updatedAtEq time.Time) ApiListIdentitiesRequest {
	r.updatedAtEq = &updatedAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtGte(updatedAtGte time.Time) ApiListIdentitiesRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtGt(updatedAtGt time.Time) ApiListIdentitiesRequest {
	r.updatedAtGt = &updatedAtGt
	return r
}

// Number of results to return.
func (r ApiListIdentitiesRequest) Limit(limit int32) ApiListIdentitiesRequest {
	r.limit = &limit
	return r
}

// Return items in ascending (ASC) or descending (DESC) order. Defaults to DESC.
func (r ApiListIdentitiesRequest) Order(order string) ApiListIdentitiesRequest {
	r.order = &order
	return r
}

// The specific method by which the returned results will be ordered.
func (r ApiListIdentitiesRequest) OrderBy(orderBy string) ApiListIdentitiesRequest {
	r.orderBy = &orderBy
	return r
}

// Cursor token for fetching the next page.
func (r ApiListIdentitiesRequest) PageCursor(pageCursor string) ApiListIdentitiesRequest {
	r.pageCursor = &pageCursor
	return r
}

// Optionally filter by Identity type
func (r ApiListIdentitiesRequest) IdentityType(identityType string) ApiListIdentitiesRequest {
	r.identityType = &identityType
	return r
}

func (r ApiListIdentitiesRequest) Execute() (*ListIdentitiesResponse, *http.Response, error) {
	return r.ApiService.ListIdentitiesExecute(r)
}

/*
ListIdentities List Identities

This endpoint enables you to fetch a list of Identities.
You can use query parameters to filter the results returned by `created_at`, `updated_at`, `summary_status` and `identity_type`

Note that this endpoint supports pagination and returns a cursor token for fetching next pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIdentitiesRequest
*/
func (a *IdentityAPIService) ListIdentities(ctx context.Context) ApiListIdentitiesRequest {
	return ApiListIdentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIdentitiesResponse
func (a *IdentityAPIService) ListIdentitiesExecute(r ApiListIdentitiesRequest) (*ListIdentitiesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIdentitiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.ListIdentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.summaryStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summary_status", r.summaryStatus, "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lt", r.createdAtLt, "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lte", r.createdAtLte, "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.eq", r.createdAtEq, "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gte", r.createdAtGte, "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gt", r.createdAtGt, "")
	}
	if r.updatedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lt", r.updatedAtLt, "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lte", r.updatedAtLte, "")
	}
	if r.updatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.eq", r.updatedAtEq, "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gte", r.updatedAtGte, "")
	}
	if r.updatedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gt", r.updatedAtGt, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.identityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identity_type", r.identityType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIdentityRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	id string
	identityPublicUpdateIdentityBody *IdentityPublicUpdateIdentityBody
}

func (r ApiUpdateIdentityRequest) IdentityPublicUpdateIdentityBody(identityPublicUpdateIdentityBody IdentityPublicUpdateIdentityBody) ApiUpdateIdentityRequest {
	r.identityPublicUpdateIdentityBody = &identityPublicUpdateIdentityBody
	return r
}

func (r ApiUpdateIdentityRequest) Execute() (*Identity, *http.Response, error) {
	return r.ApiService.UpdateIdentityExecute(r)
}

/*
UpdateIdentity Update Identity

Updates an Identity, this action performs a delta of what is submitted in the update and the existing identity.
- Updating details (`person_details` or `institution_details`) might lead to the identity being re-verified (e.g. re-screening name changes), which
could impact the identity's ability to transact on the Platform.
- Setting `set_user_disabled` to `true` will make the Identity `DISABLED` (read [more here](https://docs.paxos.com/identity/statuses) on what this means)
- Setting `tax_details` will update all the tax details for the identity
- Setting `last_kyc_refresh_date` indicates this is not an adhoc-update, and instead an update for a [periodic kyc refresh](https://docs.paxos.com/identity/kyc-refresh)

Changing an Institution Identity to a Person and vice-versa is not supported.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiUpdateIdentityRequest
*/
func (a *IdentityAPIService) UpdateIdentity(ctx context.Context, id string) ApiUpdateIdentityRequest {
	return ApiUpdateIdentityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Identity
func (a *IdentityAPIService) UpdateIdentityExecute(r ApiUpdateIdentityRequest) (*Identity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Identity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.UpdateIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.identityPublicUpdateIdentityBody == nil {
		return localVarReturnValue, nil, reportError("identityPublicUpdateIdentityBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.identityPublicUpdateIdentityBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
