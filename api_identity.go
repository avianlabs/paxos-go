/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// IdentityAPIService IdentityAPI service
type IdentityAPIService service

type ApiCreateIdentityRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	createIdentityRequest *CreateIdentityRequest
}

func (r ApiCreateIdentityRequest) CreateIdentityRequest(createIdentityRequest CreateIdentityRequest) ApiCreateIdentityRequest {
	r.createIdentityRequest = &createIdentityRequest
	return r
}

func (r ApiCreateIdentityRequest) Execute() (*Identity, *http.Response, error) {
	return r.ApiService.CreateIdentityExecute(r)
}

/*
CreateIdentity Create Identity

This enables you to create a new identity within the Paxos platform. Depending upon the fields provided, the
identity will either be person or an institution.

- [create person identity](#create-person-identity)
- [create institution identity](#create-institution-identity)

A successful response indicates that the identity has been created. This does not mean that
it has already been processed. You can use the unique ID returned within the response to check
the approval status of the identity.

### Create Person Identity
The Person identity type is used to represent individuals on the platform. Attributes of the Person identity type are recorded in the *person_details* field.

Note that fields not listed below are forbidden in this request.

Field | Notes
---|---
person_details | Required
metadata | Optional
tax_details | Optional
ref_id | Optional

For US based identities, if the `tax_details` attribute is empty, it will be backfilled with the `cip_id` and `cip_id_country` fields from the `person_details` attribute.
For international identities, the `tax_details` attribute must be present.

Currently both `JUMIO` or `PASSTHROUGH` are supported for verification, but only `JUMIO` is enabled by default.

- [create person identity with jumio verification](#automatic-id-verification-with-jumio)
- [create person identity with passthrough verification](#automatic-id-verification-with-passthrough)

#### Automatic ID Verification with Jumio
To use Jumio, you must submit the fields listed below as part of the `person_details` attribute in your request.

Field | Notes
---|---
person_details.verifier_type | Required. Must be `JUMIO`
person_details.verifier_id | Required
person_details.address | Required

Please note that when using this method:
- You must ensure that the identity has already been validated by Jumio before submitting the identity to Paxos.
- You must have previously [set the API credentials for Jumio access](#operation/SetVerifierCredentials).

Paxos will compare the provided information with the information returned from the Jumio API.

In the event that there is a conflict between the submitted data and the data returned from the identity provider,
the information from the identity provider will be preferred.

##### Example Request
<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"person_details": {
&nbsp;&nbsp;&nbsp;&nbsp;"verifier_id": "b7b77d82-e6a7-4ae9-9904-36231aedf985",
&nbsp;&nbsp;&nbsp;&nbsp;"verifier_type": "JUMIO",
&nbsp;&nbsp;&nbsp;&nbsp;"first_name": "John",
&nbsp;&nbsp;&nbsp;&nbsp;"last_name": "Doe",
&nbsp;&nbsp;&nbsp;&nbsp;"date_of_birth": "1980-01-01",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id": "111-11-1111",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id_type": "SSN",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id_country": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"nationality": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"profession": "Engineer",
&nbsp;&nbsp;&nbsp;&nbsp;"country_of_birth": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"address": {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"country": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"address1": "1 Example St",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city": "New York",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"province": "NY",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"zip_code": "10001"
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;"ref_id": "33ece656-eef1-43b5-a851-b6b9099089a5"
&nbsp;&nbsp;}
}
</code>
</pre>

#### Automatic ID Verification with Passthrough
To use Passthrough, Paxos Compliance must first confirm your eligibility.

Once confirmed, you can submit the fields listed below as part of the the `person_details` attribute in your request.

Field | Notes
---|---
person_details.verifier_type | Required. Must be `PASSTHROUGH`
person_details.passthrough_verifier_type | Required. Specifies the ID Verification provider you originally used
person_details.passthrough_verified_at | Required
person_details.address | Required

Note that the following field is forbidden in the request:
`person_details.verifier_id`

##### Example Request
<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"person_details": {
&nbsp;&nbsp;&nbsp;&nbsp;"verifier_type": "PASSTHROUGH",
&nbsp;&nbsp;&nbsp;&nbsp;"passthrough_verifier_type": "JUMIO",
&nbsp;&nbsp;&nbsp;&nbsp;"passthrough_verified_at": "2021-06-16T09:28:14Z",
&nbsp;&nbsp;&nbsp;&nbsp;"first_name": "John",
&nbsp;&nbsp;&nbsp;&nbsp;"last_name": "Doe",
&nbsp;&nbsp;&nbsp;&nbsp;"date_of_birth": "1980-01-01",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id_type": "SSN",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id": "111-11-1111",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id_country": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"nationality": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"profession": "Engineer",
&nbsp;&nbsp;&nbsp;&nbsp;"country_of_birth": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"address": {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"country": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"address1": "1 Example St",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city": "New York",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"province": "NY",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"zip_code": "10001"
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;"ref_id": "33ece656-eef1-43b5-a851-b6b9099089a5"
&nbsp;&nbsp;}
}
</code>
</pre>

### Create Institution Identity
Institution identities are used to represent all non-person entities.
Details for institution identity type are recorded in `institution_details`. An institution identity also has `institution_members` associated with it. This defines persons or other entities that have some relationship to the institution.

We support the following types and sub-types of institutions. Note that all institution types listed do share some common validations that can also be found below.

#### Supported Institution Types

institution_type | Supported institution_member roles | Notes
---| ---| ---
`TRUST` | `BENEFICIAL_OWNER`<br>`BENEFICIARY`<br>`GRANTOR`<br>`TRUSTEE` | [See Trusts](#trust-institutions-requirement)
`CORPORATION`<br>`LLC`<br>`PARTNERSHIP` | `ACCOUNT_OPENER`<br>`AUTHORIZED_USER`<br>`BENEFICIAL_OWNER`<br>`MANAGEMENT_CONTROL_PERSON` | [See other Institutions](#institutions-requirement)

#### Industry Type to Institution Subtypes Mapping
institution_sub_type | industry
---| ---
`ACCOMMODATION_FOOD_SERVICES` |   Food or Beverage Services
`ADMINISTRATIVE_SUPPORT_WASTE_MANAGEMENT_REMEDIATION_SERVICES` |  Administrative and Support Services
`ADULT_ENTERTAINMENT` | Adult Entertainment / Pornography
`AGRICULTURE_FORESTRY_FISHING_HUNTING` | Agriculture
`ARTS_ENTERTAINMENT_RECREATION` | Arts, Entertainment, and Recreation
`AUCTIONS` | Auction Houses / Art Galleries
`AUTOMOBILES` | Automobiles / Automotives
`BLOCKCHAIN` | Blockchain Technology
`CONSTRUCTION` | Construction
`CRYPTO` | Crypto Services and Products (Mining, Exchange, Broker)
`DRUGS` | Illicit Drugs / Drug Paraphernalia
`E_COMMERCE` | E-Commerce
`EDUCATIONAL_SERVICES` | Educational Services
`EXPORT_IMPORT` | Export / Import Companies
`FINANCE_INSURANCE` | Other Financial & Insurance Services (Not Referenced Elsewhere)
`FINANCIAL_INSTITUTION` | Financial Institution
`GAMBLING` | Gaming, Gambling, Casinos, or Sports Betting
`HEALTH_CARE_SOCIAL_ASSISTANCE` | Health Care and Social Assistance
`HEDGE_FUND` | Pooled Investment Vehicle / Investment Fund / Hedge Fund
`INFORMATION` | Information, Communications, and Media
`INSURANCE` | Insurance
`INVESTMENT` | Investment
`MANAGEMENT_OF_COMPANIES_ENTERPRISES` | Management of Companies & Enterprises (Holding Companies)
`MANUFACTURING` | Manufacturing
`MARKET_MAKER` | Market Maker / Proprietary Trading
`MINING` | Oil & Gas
`MONEY_SERVICE_BUSINESS` | Money Services Business / Money Transmitters (including ATMs)
`NON_PROFIT` | Non-Profit, Charity or Political Organizations
`OTHER_SERVICES` | Other
`PRECIOUS_METALS` | Jewelry or Precious Metals (Mining, Transportation, Dealing or Retail)
`PROFESSIONAL_SCIENTIFIC_TECHNICAL_SERVICES` | Professional Services (Consulting, Legal, Accounting, etc.)
`PUBLIC_ADMINISTRATION` | Public or Government Services
`RANSOMWARE` | Ransomware / Facilitators of Ransomware Transactions
`REAL_ESTATE_RENTAL_LEASING` | Real Estate and Rental and Leasing
`REGISTERED_INVESTMENT_ADVISOR` | Registered Investment Advisor
`RETAIL_TRADE` | Retail Trade
`SHELL_BANK` | Shell Banks or Shell Companies
`STO_ISSUER` | Security Token Offering (STO) Issuer
`TRANSPORTATION_WAREHOUSING` | Transportation and Services
`TRAVEL_TRANSPORT` | Travel, Accomodation or Transport
`UTILITIES` | Utilities
`WEAPONS` | Weapons or Arms (Manufacturing, Sales or Transportation)
`WHOLESALE_TRADE` | Wholesale Trade

Notes:
- `INVESTMENT` is only supported by the institution type `TRUST`.
- All other subtypes are only supported by types `CORPORATION`, `LLC` and `PARTNERSHIP`.

#### Prohibited Institution Subtypes

Paxos prohibits certain types of business activity (“Prohibited Businesses”) in accordance with its Compliance policies.
The following non-exhaustive list is representative of the type of activity that Paxos prohibits on its platform.
By creating a Paxos Identity, Paxos customers agree not to use Paxos services in connection with any of the following Prohibited Businesses.

- `ADULT_ENTERTAINMENT`
- `DRUGS`
- `RANSOMWARE`
- `SHELL_BANK`
- `WEAPONS`

#### Shared Validations Across All Institution Types

Field | Notes
---|---
cip_id | One of EIN, REGISTRATION_NUMBER, SSN, ITIN. SSN and ITIN are only supported for passthrough/revocable entities.
tax_details | Automatically populated if the cip_id_type is SSN, ITIN or EIN.
tax_details_not_required | Can be set for non-US institutions where tax details are not required.
metadata | Optional
ref_id | Optional

#### Specifying Institution Members and Their Roles

Field | Notes
---|---
identity_id | Required
roles | Required.
ownership | Optional. Must be between 0 and 100
position | Optional

Note
See supported institution types for details on which roles are supported by which institution type.

#### Fields Required for Trusts

Type | Fields
---|---
Required | name, cip_id, cip_id_type, cip_id_country, institution_type, institution_sub_type, business_address, govt_registration_date
Optional | phone_number, email, incorporation_address, regulation_status, trading_type, listed_exchange, ticker_symbol, parent_institution_name, regulator_jurisdiction, regulator_name, regulator_register_number

Notes
Fields not listed are forbidden in the request. `institution_type` must be set to TRUST. `institution_sub_type` must be set to Investment.
`incorporation_address` is required for Trusts where their cip_id_type is not SSN or ITIN.

##### Example Request for a Trust
<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"institution_members": [{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "33ece656-eef1-43b5-a851-b6b9099089a5",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["GRANTOR"]
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "44ece656-eef1-43b5-a851-b6b9099089a6",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["TRUSTEE"]
&nbsp;&nbsp;&nbsp;&nbsp;}],
&nbsp;&nbsp;"institution_details": {
&nbsp;&nbsp;&nbsp;&nbsp;"name": "Trust A",
&nbsp;&nbsp;&nbsp;&nbsp;"business_address": {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"country": "United States",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"address1": "1 Example St",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city": "New York",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"province": "NY",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"zip_code": "10001"
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;"email": "institution_a@acorp.com",
&nbsp;&nbsp;&nbsp;&nbsp;"institution_type": "CORPORATION",
&nbsp;&nbsp;&nbsp;&nbsp;"institution_sub_type": "HEDGE_FUND",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id": "11-1111111",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id_type": "EIN",
&nbsp;&nbsp;&nbsp;&nbsp;"cip_id_country": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"govt_registration_date": "2021-04-14T00:00:00Z",
&nbsp;&nbsp;&nbsp;&nbsp;"incorporation_address": {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"country": "United States",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"address1": "1 Example St",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"city": "New York",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"province": "NY",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"zip_code": "10001"
&nbsp;&nbsp;&nbsp;&nbsp;},
&nbsp;&nbsp;&nbsp;&nbsp;"regulation_status": "US_REGULATED",
&nbsp;&nbsp;&nbsp;&nbsp;"trading_type": "PUBLIC",
&nbsp;&nbsp;&nbsp;&nbsp;"listed_exchange": "NASDAQ",
&nbsp;&nbsp;&nbsp;&nbsp;"ticker_symbol": "ABC",
&nbsp;&nbsp;&nbsp;&nbsp;"regulator_name": "SEC",
&nbsp;&nbsp;&nbsp;&nbsp;"regulator_jurisdiction": "USA",
&nbsp;&nbsp;&nbsp;&nbsp;"regulator_register_number": "111-111111"
&nbsp;&nbsp;}
}
</code>
</pre>

#### Fields Required for Institutions (excluding Trusts and Registered Investment Advisors)

Type | Fields
---|---
Required | name, cip_id, cip_id_type, cip_id_country, institution_type, institution_sub_type, business_address, incorporation_address, govt_registration_date, regulation_status, trading_type
Optional | phone_number, email, listed_exchange, ticker_symbol, parent_institution_name, regulator_jurisdiction, regulator_name, regulator_register_number

#### Creating Financially Regulated Institutions
Please refer to the following table for creating institutions which are financially regulated.

regulation_status | Notes
---|---
US_REGULATED | Institution financially regulated in the US
INTL_REGULATED | Institution financially regulated by an international entity
NON_REGULATED | Non-financially regulated institution

Note that each category of `regulation_status` then has additional validations tied to `trading type` and other required fields.

regulation_status | trading_type | fields required | Notes
---|---|---|---
US_REGULATED | PRIVATE | regulator_name, regulator_jurisdiction, regulator_register_number | Not publicly traded
US_REGULATED | PUBLIC | listed_ exchange, ticker_symbol, regulator_name, regulator_jurisdiction, regulator_register_number | Publicly traded
US_REGULATED | PUBLICLY_TRADED_SUBSIDIARY | listed_exchange, ticker_symbol, regulator_name, regulator_jurisdiction, regulator_register_number, parent_institution_name | Subsidiary of a publicly traded company
INTL_REGULATED | PRIVATE | regulator_name, regulator_jurisdiction, regulator_register_number | Not publicly traded
INTL_REGULATED | PUBLIC | listed_ exchange, ticker_symbol, regulator_name, regulator_jurisdiction, regulator_register_number | Publicly traded
INTL_REGULATED | PUBLICLY_TRADED_SUBSIDIARY | listed_exchange, ticker_symbol, regulator_name, regulator_jurisdiction, regulator_register_number, parent_institution_name | Subsidiary of a publicly traded company
NON_REGULATED | PRIVATE | PRIVATE | Not publicly traded
NON_REGULATED | PUBLIC | listed_exchange, ticker_symbol | Publicly traded

#### Fields required for Registered Investment Advisors (RIA)

RIAs are a special sub-type of Institution. Usage of this sub-type requires prior authorization and approval from Paxos.

Notes
`institution_sub_type` must be set to REGISTERED_INVESTMENT_ADVISOR. The list of required and optional fields below varies slightly from other supported institutions
while certain fields are optional (e.g. trading_type), if they are specified in the request, their input will been validated

Type | Fields
---|---
Required | name, cip_id, cip_id_type, cip_id_country, institution_type, institution_sub_type, business_address, regulation_status, regulator_jurisdiction, regulator_name, regulator_register_number
Optional | phone_number, email, listed_exchange, ticker_symbol, parent_institution_name, incorporation_address, govt_registration_date, trading_type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIdentityRequest
*/
func (a *IdentityAPIService) CreateIdentity(ctx context.Context) ApiCreateIdentityRequest {
	return ApiCreateIdentityRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Identity
func (a *IdentityAPIService) CreateIdentityExecute(r ApiCreateIdentityRequest) (*Identity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Identity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.CreateIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIdentityRequest == nil {
		return localVarReturnValue, nil, reportError("createIdentityRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIdentityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Problem
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIdentityRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	id string
	includeDetails *bool
	includeInstitutionMembers *bool
}

// query param; details are encrypted, so we do not want to include them by default
func (r ApiGetIdentityRequest) IncludeDetails(includeDetails bool) ApiGetIdentityRequest {
	r.includeDetails = &includeDetails
	return r
}

// query param; to include institution members for institution identity
func (r ApiGetIdentityRequest) IncludeInstitutionMembers(includeInstitutionMembers bool) ApiGetIdentityRequest {
	r.includeInstitutionMembers = &includeInstitutionMembers
	return r
}

func (r ApiGetIdentityRequest) Execute() (*Identity, *http.Response, error) {
	return r.ApiService.GetIdentityExecute(r)
}

/*
GetIdentity Get Identity

Get an identity by ID. By default, the identity details (person_details or institution_details) will not be returned.
Set `?include_details=true` to receive them in the response. For institution type identities,
members will not be returned in the default response. Set `?include_institution_members=true` to get the members.

An identity is allowed to transact on the Paxos platform when `summary_status` is `"APPROVED"`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id id associated with the identity
 @return ApiGetIdentityRequest
*/
func (a *IdentityAPIService) GetIdentity(ctx context.Context, id string) ApiGetIdentityRequest {
	return ApiGetIdentityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Identity
func (a *IdentityAPIService) GetIdentityExecute(r ApiGetIdentityRequest) (*Identity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Identity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.GetIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeDetails != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_details", r.includeDetails, "")
	}
	if r.includeInstitutionMembers != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_institution_members", r.includeInstitutionMembers, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIdentitiesRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	summaryStatus *string
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtEq *time.Time
	createdAtGte *time.Time
	createdAtGt *time.Time
	updatedAtLt *time.Time
	updatedAtLte *time.Time
	updatedAtEq *time.Time
	updatedAtGte *time.Time
	updatedAtGt *time.Time
	limit *int32
	order *string
	orderBy *string
	pageCursor *string
	identityType *string
}

// Summary Status of the Identity.
func (r ApiListIdentitiesRequest) SummaryStatus(summaryStatus string) ApiListIdentitiesRequest {
	r.summaryStatus = &summaryStatus
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtLt(createdAtLt time.Time) ApiListIdentitiesRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtLte(createdAtLte time.Time) ApiListIdentitiesRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtEq(createdAtEq time.Time) ApiListIdentitiesRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtGte(createdAtGte time.Time) ApiListIdentitiesRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) CreatedAtGt(createdAtGt time.Time) ApiListIdentitiesRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtLt(updatedAtLt time.Time) ApiListIdentitiesRequest {
	r.updatedAtLt = &updatedAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtLte(updatedAtLte time.Time) ApiListIdentitiesRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtEq(updatedAtEq time.Time) ApiListIdentitiesRequest {
	r.updatedAtEq = &updatedAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtGte(updatedAtGte time.Time) ApiListIdentitiesRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIdentitiesRequest) UpdatedAtGt(updatedAtGt time.Time) ApiListIdentitiesRequest {
	r.updatedAtGt = &updatedAtGt
	return r
}

// Number of results to return.
func (r ApiListIdentitiesRequest) Limit(limit int32) ApiListIdentitiesRequest {
	r.limit = &limit
	return r
}

// Return items in ascending (ASC) or descending (DESC) order. Defaults to DESC.
func (r ApiListIdentitiesRequest) Order(order string) ApiListIdentitiesRequest {
	r.order = &order
	return r
}

// The specific method by which the returned results will be ordered.
func (r ApiListIdentitiesRequest) OrderBy(orderBy string) ApiListIdentitiesRequest {
	r.orderBy = &orderBy
	return r
}

// Cursor token for fetching the next page.
func (r ApiListIdentitiesRequest) PageCursor(pageCursor string) ApiListIdentitiesRequest {
	r.pageCursor = &pageCursor
	return r
}

// Optionally filter by Identity type
func (r ApiListIdentitiesRequest) IdentityType(identityType string) ApiListIdentitiesRequest {
	r.identityType = &identityType
	return r
}

func (r ApiListIdentitiesRequest) Execute() (*ListIdentitiesResponse, *http.Response, error) {
	return r.ApiService.ListIdentitiesExecute(r)
}

/*
ListIdentities List Identities

This endpoint enables you to fetch a list of identities that you have created within the Paxos platform. You
can use query parameters to filter the results returned by:
- Summary Status of the Identity
- Date created
- Date updated

Note that this endpoint supports pagination and returns a cursor token for fetching next pages.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIdentitiesRequest
*/
func (a *IdentityAPIService) ListIdentities(ctx context.Context) ApiListIdentitiesRequest {
	return ApiListIdentitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIdentitiesResponse
func (a *IdentityAPIService) ListIdentitiesExecute(r ApiListIdentitiesRequest) (*ListIdentitiesResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIdentitiesResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.ListIdentities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.summaryStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "summary_status", r.summaryStatus, "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lt", r.createdAtLt, "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lte", r.createdAtLte, "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.eq", r.createdAtEq, "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gte", r.createdAtGte, "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gt", r.createdAtGt, "")
	}
	if r.updatedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lt", r.updatedAtLt, "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lte", r.updatedAtLte, "")
	}
	if r.updatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.eq", r.updatedAtEq, "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gte", r.updatedAtGte, "")
	}
	if r.updatedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gt", r.updatedAtGt, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.identityType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identity_type", r.identityType, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateIdentityRequest struct {
	ctx context.Context
	ApiService *IdentityAPIService
	id string
	updateIdentityRequest *UpdateIdentityRequest
}

func (r ApiUpdateIdentityRequest) UpdateIdentityRequest(updateIdentityRequest UpdateIdentityRequest) ApiUpdateIdentityRequest {
	r.updateIdentityRequest = &updateIdentityRequest
	return r
}

func (r ApiUpdateIdentityRequest) Execute() (*Identity, *http.Response, error) {
	return r.ApiService.UpdateIdentityExecute(r)
}

/*
UpdateIdentity Update Identity

This enables you to update an existing identity with new information. Please note that:
- Updating any field other than `set_user_disabled`, `metadata` or `ref_id` will transition the identity to a PENDING status.
This will restrict the identity until it has been re-verified.
- Setting `set_user_disabled` to `true` will disable the identity, limiting its ability to be used within
the Paxos platform.
- Details of the identity can be updated by providing `person_details` or `institution_details` depending upon the type.
- You can add, update or remove tax_details by providing the `tax_details` list. The tax_details will be updated to exactly
comprise the given list

Note: Identity conversion from person to institution type or vice-versa is not permitted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiUpdateIdentityRequest
*/
func (a *IdentityAPIService) UpdateIdentity(ctx context.Context, id string) ApiUpdateIdentityRequest {
	return ApiUpdateIdentityRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Identity
func (a *IdentityAPIService) UpdateIdentityExecute(r ApiUpdateIdentityRequest) (*Identity, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Identity
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IdentityAPIService.UpdateIdentity")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/identities/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateIdentityRequest == nil {
		return localVarReturnValue, nil, reportError("updateIdentityRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateIdentityRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
