/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// AccountsAPIService AccountsAPI service
type AccountsAPIService service

type ApiCreateAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	createAccountRequest *CreateAccountRequest
}

func (r ApiCreateAccountRequest) CreateAccountRequest(createAccountRequest CreateAccountRequest) ApiCreateAccountRequest {
	r.createAccountRequest = &createAccountRequest
	return r
}

func (r ApiCreateAccountRequest) Execute() (*Account, *http.Response, error) {
	return r.ApiService.CreateAccountExecute(r)
}

/*
CreateAccount Create Account

Create an account for a given identity, via the `identity_id` field.
This identity is the primary owner of the account for all tax-related purposes.

To track user balances using Paxos [Profiles](#tag/Profiles), use `create_profile=true` when creating the account.
Once an account has been created, it is not possible to associate it with a [Profile](#tag/Profiles).

### Account Members

In addition to the primary owner, other identities may be associated with the account, by using `members`.
The identity on the account is treated as a BENEFICIAL_OWNER.

To add a financial advisor to an account, add a member with the FINANCIAL_ADVISOR role.

#### Example
This example request creates a joint account for John and Jane Doe. John has identity_id=82c338f4-3cb7-4d9b-be2a-4b077c82ee3a,
and Jane has identity_id=0f5d8475-33f3-4ebd-88a0-66dedc2581c1. John is the primary owner of the account for tax-purposes, but Jane
is a full beneficial owner.

Additionally, this account has an associated financial advisor with identity_id=0d26f878-298e-4d47-81be-cdf4e982a3d3.

<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"account": {
&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "82c338f4-3cb7-4d9b-be2a-4b077c82ee3a",
&nbsp;&nbsp;&nbsp;&nbsp;"members": [{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "0f5d8475-33f3-4ebd-88a0-66dedc2581c1",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["BENEFICIAL_OWNER"]
&nbsp;&nbsp;&nbsp;&nbsp;}, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "0d26f878-298e-4d47-81be-cdf4e982a3d3",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["FINANCIAL_ADVISOR"]
&nbsp;&nbsp;&nbsp;&nbsp;}]
&nbsp;&nbsp;}
}
</code>
</pre>

### Fields

Any fields not listed are forbidden in this request.

Field | Notes
---|---
identity_id | Required
description | Optional
metadata | Optional
ref_id | Optional
members | Optional

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccountRequest
*/
func (a *AccountsAPIService) CreateAccount(ctx context.Context) ApiCreateAccountRequest {
	return ApiCreateAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Account
func (a *AccountsAPIService) CreateAccountExecute(r ApiCreateAccountRequest) (*Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.CreateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createAccountRequest == nil {
		return localVarReturnValue, nil, reportError("createAccountRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAccountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	id string
}

func (r ApiGetAccountRequest) Execute() (*Account, *http.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Method for GetAccount

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id uuid id of account
 @return ApiGetAccountRequest
*/
func (a *AccountsAPIService) GetAccount(ctx context.Context, id string) ApiGetAccountRequest {
	return ApiGetAccountRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return Account
func (a *AccountsAPIService) GetAccountExecute(r ApiGetAccountRequest) (*Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/accounts/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAccountsRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	pageCursor *string
	order *string
	orderBy *string
	limit *int32
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtEq *time.Time
	createdAtGte *time.Time
	createdAtGt *time.Time
	identityId *string
	updatedAtLt *time.Time
	updatedAtLte *time.Time
	updatedAtEq *time.Time
	updatedAtGte *time.Time
	updatedAtGt *time.Time
}

func (r ApiListAccountsRequest) PageCursor(pageCursor string) ApiListAccountsRequest {
	r.pageCursor = &pageCursor
	return r
}

// Return items in ascending (ASC) or descending (DESC) order. Defaults to DESC.
func (r ApiListAccountsRequest) Order(order string) ApiListAccountsRequest {
	r.order = &order
	return r
}

// The specific method by which the returned results will be ordered.
func (r ApiListAccountsRequest) OrderBy(orderBy string) ApiListAccountsRequest {
	r.orderBy = &orderBy
	return r
}

// Number of results to return.
func (r ApiListAccountsRequest) Limit(limit int32) ApiListAccountsRequest {
	r.limit = &limit
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) CreatedAtLt(createdAtLt time.Time) ApiListAccountsRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) CreatedAtLte(createdAtLte time.Time) ApiListAccountsRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) CreatedAtEq(createdAtEq time.Time) ApiListAccountsRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) CreatedAtGte(createdAtGte time.Time) ApiListAccountsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) CreatedAtGt(createdAtGt time.Time) ApiListAccountsRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Optionally filter by primary identity identity.
func (r ApiListAccountsRequest) IdentityId(identityId string) ApiListAccountsRequest {
	r.identityId = &identityId
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) UpdatedAtLt(updatedAtLt time.Time) ApiListAccountsRequest {
	r.updatedAtLt = &updatedAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) UpdatedAtLte(updatedAtLte time.Time) ApiListAccountsRequest {
	r.updatedAtLte = &updatedAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) UpdatedAtEq(updatedAtEq time.Time) ApiListAccountsRequest {
	r.updatedAtEq = &updatedAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) UpdatedAtGte(updatedAtGte time.Time) ApiListAccountsRequest {
	r.updatedAtGte = &updatedAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListAccountsRequest) UpdatedAtGt(updatedAtGt time.Time) ApiListAccountsRequest {
	r.updatedAtGt = &updatedAtGt
	return r
}

func (r ApiListAccountsRequest) Execute() (*ListAccountsResponse, *http.Response, error) {
	return r.ApiService.ListAccountsExecute(r)
}

/*
ListAccounts List Accounts

List accounts with pagination. Every response will contain a `next_page` field,
as long as the end of the list has not been reached. Pass this value into the `page_cursor` field of the next request
to retrieve the next page of results.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAccountsRequest
*/
func (a *AccountsAPIService) ListAccounts(ctx context.Context) ApiListAccountsRequest {
	return ApiListAccountsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListAccountsResponse
func (a *AccountsAPIService) ListAccountsExecute(r ApiListAccountsRequest) (*ListAccountsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListAccountsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.ListAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lt", r.createdAtLt, "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lte", r.createdAtLte, "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.eq", r.createdAtEq, "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gte", r.createdAtGte, "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gt", r.createdAtGt, "")
	}
	if r.identityId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "identity_id", r.identityId, "")
	}
	if r.updatedAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lt", r.updatedAtLt, "")
	}
	if r.updatedAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.lte", r.updatedAtLte, "")
	}
	if r.updatedAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.eq", r.updatedAtEq, "")
	}
	if r.updatedAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gte", r.updatedAtGte, "")
	}
	if r.updatedAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at.gt", r.updatedAtGt, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccountRequest struct {
	ctx context.Context
	ApiService *AccountsAPIService
	updateAccountRequest *UpdateAccountRequest
}

func (r ApiUpdateAccountRequest) UpdateAccountRequest(updateAccountRequest UpdateAccountRequest) ApiUpdateAccountRequest {
	r.updateAccountRequest = &updateAccountRequest
	return r
}

func (r ApiUpdateAccountRequest) Execute() (*Account, *http.Response, error) {
	return r.ApiService.UpdateAccountExecute(r)
}

/*
UpdateAccount Update Account

This enables you to update an existing account with new information. Please refer to the following
table for fields that can be updated via this endpoint.

Field | Notes
---|---
account.id | Required
account.description | Optional
account.ref_id | Optional
account.metadata | Optional. This will overwrite any existing metadata added to the account.
account.members | Optional. The only roles that can be added/removed are `FINANCIAL_ADVISOR` or `AUTHORIZED_USER.` You must always specify the full members object as we do not currently support differential member updates.
set_user_disabled | Optional. Setting this to `true` will disable the account, limiting its ability to be used within the Paxos platform.

#### Example Requests
#### Disabling an account

<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"set_user_disabled": true,
&nbsp;&nbsp;"account": {
&nbsp;&nbsp;&nbsp;&nbsp;"id": "82c338f4-3cb7-4d9b-be2a-4b077c82ee3a",
&nbsp;&nbsp;&nbsp;&nbsp;"description": "Account Description",
&nbsp;&nbsp;&nbsp;&nbsp;"ref_id": "82c338f4-3cb7",
&nbsp;&nbsp;}
}
</code>
</pre>

### Adding an account member
To retain the existing account members and add a new account member, the `members` field must contain the existing account members and the
new member. The below example adds an `AUTHORIZED_USER` to the account.

In order to add account members while leaving existing account members unaffected, clients
should use the [Add Account Members](#operation/AddAccountMembers) API.

<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"account": {
&nbsp;&nbsp;&nbsp;&nbsp;"id": "82c338f4-3cb7-4d9b-be2a-4b077c82ee3a",
&nbsp;&nbsp;&nbsp;&nbsp;"members": [{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "0f5d8475-33f3-4ebd-88a0-66dedc2581c1",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["BENEFICIAL_OWNER"]
&nbsp;&nbsp;&nbsp;&nbsp;}, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "0d26f878-298e-4d47-81be-cdf4e982a3d3",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["FINANCIAL_ADVISOR"]
&nbsp;&nbsp;&nbsp;&nbsp;}, {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "012k23eb-298e-4d47-81be-cdf4e982a3d3",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["AUTHORIZED_USER"]
&nbsp;&nbsp;&nbsp;&nbsp;}]
&nbsp;&nbsp;}
}
</code>
</pre>

### Removing an account member
To remove an existing account member and retain other needed members, the `members` field must contain
the existing account members without the account member you'd like to remove. The below example removes an `AUTHORIZED_USER` from the account.

Note, this API requires the `members` array to have at least one element. In order to delete all members
from an account, clients should use the [Delete Account Member](#operation/DeleteAccountMember) API.

<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"account": {
&nbsp;&nbsp;&nbsp;&nbsp;"id": "82c338f4-3cb7-4d9b-be2a-4b077c82ee3a",
&nbsp;&nbsp;&nbsp;&nbsp;"members": [{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "0f5d8475-33f3-4ebd-88a0-66dedc2581c1",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["BENEFICIAL_OWNER"]
&nbsp;&nbsp;&nbsp;&nbsp;}]
&nbsp;&nbsp;}
}
</code>
</pre>

### Updating an account members' roles
To update an account members' roles, the `members` field must contain all the existing members with their roles along
with the additional role that you'd like to add or remove. The below example adds the `FINANCIAL_ADVISOR` role to an member that is already a `BENEFICIAL_OWNER`.

<!--indentation does not work in swagger code blocks-->
<pre>
<code>
{
&nbsp;&nbsp;"account": {
&nbsp;&nbsp;&nbsp;&nbsp;"id": "82c338f4-3cb7-4d9b-be2a-4b077c82ee3a",
&nbsp;&nbsp;&nbsp;&nbsp;"members": [{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"identity_id": "0f5d8475-33f3-4ebd-88a0-66dedc2581c1",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"roles": ["BENEFICIAL_OWNER", "FINANCIAL_ADVISOR"]
&nbsp;&nbsp;&nbsp;&nbsp;}]
&nbsp;&nbsp;}
}
</code>
</pre>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAccountRequest
*/
func (a *AccountsAPIService) UpdateAccount(ctx context.Context) ApiUpdateAccountRequest {
	return ApiUpdateAccountRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Account
func (a *AccountsAPIService) UpdateAccountExecute(r ApiUpdateAccountRequest) (*Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AccountsAPIService.UpdateAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/identity/accounts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateAccountRequest == nil {
		return localVarReturnValue, nil, reportError("updateAccountRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateAccountRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
