/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


// TaxLotAPIService TaxLotAPI service
type TaxLotAPIService service

type ApiGetTaxLotRequest struct {
	ctx context.Context
	ApiService *TaxLotAPIService
	id string
}

func (r ApiGetTaxLotRequest) Execute() (*TaxLot, *http.Response, error) {
	return r.ApiService.GetTaxLotExecute(r)
}

/*
GetTaxLot Get Tax Lot

Get Tax Lot allows you to retrieve tax lot detail by its id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The UUID of the tax lot
 @return ApiGetTaxLotRequest
*/
func (a *TaxLotAPIService) GetTaxLot(ctx context.Context, id string) ApiGetTaxLotRequest {
	return ApiGetTaxLotRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TaxLot
func (a *TaxLotAPIService) GetTaxLotExecute(r ApiGetTaxLotRequest) (*TaxLot, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxLot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxLotAPIService.GetTaxLot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax/tax-lots/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTaxLotsRequest struct {
	ctx context.Context
	ApiService *TaxLotAPIService
	taxLotIds *[]string
	profileIds *[]string
	accountIds *[]string
	transactionTypes *[]string
	status *string
	cryptocurrency *string
	capitalGainType *string
	createdAtLt *time.Time
	createdAtLte *time.Time
	createdAtEq *time.Time
	createdAtGte *time.Time
	createdAtGt *time.Time
	limit *int32
	order *string
	orderBy *string
	pageCursor *string
}

// A list of tax lot ids. Must be provided if no profile ids nor account ids provided.
func (r ApiListTaxLotsRequest) TaxLotIds(taxLotIds []string) ApiListTaxLotsRequest {
	r.taxLotIds = &taxLotIds
	return r
}

// A list of profile ids. Can not be provided together with account ids.
func (r ApiListTaxLotsRequest) ProfileIds(profileIds []string) ApiListTaxLotsRequest {
	r.profileIds = &profileIds
	return r
}

// A list of account ids. Can not be provided together with profile ids.
func (r ApiListTaxLotsRequest) AccountIds(accountIds []string) ApiListTaxLotsRequest {
	r.accountIds = &accountIds
	return r
}

// A list of transaction types. Requires profile ids or account ids to be provided.
func (r ApiListTaxLotsRequest) TransactionTypes(transactionTypes []string) ApiListTaxLotsRequest {
	r.transactionTypes = &transactionTypes
	return r
}

// Status of tax lot, OPEN or CLOSED. Requires profile ids or account ids to be provided.
func (r ApiListTaxLotsRequest) Status(status string) ApiListTaxLotsRequest {
	r.status = &status
	return r
}

// Crypto currency of the tax lot. Requires profile ids or account ids to be provided.
func (r ApiListTaxLotsRequest) Cryptocurrency(cryptocurrency string) ApiListTaxLotsRequest {
	r.cryptocurrency = &cryptocurrency
	return r
}

// The capital gain type, values of LONG_TERM, SHORT_TERM, EXEMPT. Requires profile ids or account ids to be provided.
func (r ApiListTaxLotsRequest) CapitalGainType(capitalGainType string) ApiListTaxLotsRequest {
	r.capitalGainType = &capitalGainType
	return r
}

// Include timestamps strictly less than lt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTaxLotsRequest) CreatedAtLt(createdAtLt time.Time) ApiListTaxLotsRequest {
	r.createdAtLt = &createdAtLt
	return r
}

// Include timestamps less than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTaxLotsRequest) CreatedAtLte(createdAtLte time.Time) ApiListTaxLotsRequest {
	r.createdAtLte = &createdAtLte
	return r
}

// Include timestamps exactly equal to eq. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTaxLotsRequest) CreatedAtEq(createdAtEq time.Time) ApiListTaxLotsRequest {
	r.createdAtEq = &createdAtEq
	return r
}

// Include timestamps greater than or equal to lte. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTaxLotsRequest) CreatedAtGte(createdAtGte time.Time) ApiListTaxLotsRequest {
	r.createdAtGte = &createdAtGte
	return r
}

// Include timestamps strictly greater than gt. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListTaxLotsRequest) CreatedAtGt(createdAtGt time.Time) ApiListTaxLotsRequest {
	r.createdAtGt = &createdAtGt
	return r
}

// Number of results to return. Default value is 100.
func (r ApiListTaxLotsRequest) Limit(limit int32) ApiListTaxLotsRequest {
	r.limit = &limit
	return r
}

// Return items in ascending (ASC) or descending (DESC) order. Defaults to DESC.
func (r ApiListTaxLotsRequest) Order(order string) ApiListTaxLotsRequest {
	r.order = &order
	return r
}

// The specific method by which the returned results will be ordered.
func (r ApiListTaxLotsRequest) OrderBy(orderBy string) ApiListTaxLotsRequest {
	r.orderBy = &orderBy
	return r
}

// Cursor token for fetching the next page.
func (r ApiListTaxLotsRequest) PageCursor(pageCursor string) ApiListTaxLotsRequest {
	r.pageCursor = &pageCursor
	return r
}

func (r ApiListTaxLotsRequest) Execute() (*ListTaxLotsResponse, *http.Response, error) {
	return r.ApiService.ListTaxLotsExecute(r)
}

/*
ListTaxLots List Tax Lots

List Tax Lots using filter, result is paginated.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTaxLotsRequest
*/
func (a *TaxLotAPIService) ListTaxLots(ctx context.Context) ApiListTaxLotsRequest {
	return ApiListTaxLotsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListTaxLotsResponse
func (a *TaxLotAPIService) ListTaxLotsExecute(r ApiListTaxLotsRequest) (*ListTaxLotsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListTaxLotsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxLotAPIService.ListTaxLots")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax/tax-lots"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.taxLotIds != nil {
		t := *r.taxLotIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tax_lot_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tax_lot_ids", t, "form", "multi")
		}
	}
	if r.profileIds != nil {
		t := *r.profileIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "profile_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "profile_ids", t, "form", "multi")
		}
	}
	if r.accountIds != nil {
		t := *r.accountIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "account_ids", t, "form", "multi")
		}
	}
	if r.transactionTypes != nil {
		t := *r.transactionTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_types", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_types", t, "form", "multi")
		}
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.cryptocurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cryptocurrency", r.cryptocurrency, "form", "")
	}
	if r.capitalGainType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "capital_gain_type", r.capitalGainType, "form", "")
	}
	if r.createdAtLt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lt", r.createdAtLt, "form", "")
	}
	if r.createdAtLte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.lte", r.createdAtLte, "form", "")
	}
	if r.createdAtEq != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.eq", r.createdAtEq, "form", "")
	}
	if r.createdAtGte != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gte", r.createdAtGte, "form", "")
	}
	if r.createdAtGt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at.gt", r.createdAtGt, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTaxLotRequest struct {
	ctx context.Context
	ApiService *TaxLotAPIService
	id string
	updateTaxLotRequest *UpdateTaxLotRequest
}

func (r ApiUpdateTaxLotRequest) UpdateTaxLotRequest(updateTaxLotRequest UpdateTaxLotRequest) ApiUpdateTaxLotRequest {
	r.updateTaxLotRequest = &updateTaxLotRequest
	return r
}

func (r ApiUpdateTaxLotRequest) Execute() (*TaxLot, *http.Response, error) {
	return r.ApiService.UpdateTaxLotExecute(r)
}

/*
UpdateTaxLot Update Tax Lot

Update Tax Lot allows you to update the tax lot specified by its ID. The updated tax lot will be returned in the response.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The UUID of the tax lot.
 @return ApiUpdateTaxLotRequest
*/
func (a *TaxLotAPIService) UpdateTaxLot(ctx context.Context, id string) ApiUpdateTaxLotRequest {
	return ApiUpdateTaxLotRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TaxLot
func (a *TaxLotAPIService) UpdateTaxLotExecute(r ApiUpdateTaxLotRequest) (*TaxLot, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TaxLot
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TaxLotAPIService.UpdateTaxLot")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tax/tax-lots/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateTaxLotRequest == nil {
		return localVarReturnValue, nil, reportError("updateTaxLotRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateTaxLotRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
