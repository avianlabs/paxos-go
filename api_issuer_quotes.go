/*
Paxos API

<p>Welcome to Paxos APIs. At Paxos, our mission is to enable the movement of any asset, any time, in a trustworthy way. These APIs serve that mission by making it easier than ever for you to directly integrate our product capabilities into your application, leveraging the speed, stability, and security of the Paxos platform.</p> <p>The documentation that follows gives you access to our Crypto Brokerage, Trading, and Exchange products. It includes APIs for market data, orders, and the held rate quote flow.</p> <p>To test in our sandbox environment, <a href=\"https://account.sandbox.paxos.com\" target=\"_blank\">sign up</a> for an account. For more information about Paxos and our APIs, visit <a href=\"https://www.paxos.com/\" target=\"_blank\">Paxos.com</a>.</p> 

API version: 2.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package paxos

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// IssuerQuotesAPIService IssuerQuotesAPI service
type IssuerQuotesAPIService service

type ApiCreateIssuerQuoteRequest struct {
	ctx context.Context
	ApiService *IssuerQuotesAPIService
	createIssuerQuoteRequest *CreateIssuerQuoteRequest
}

func (r ApiCreateIssuerQuoteRequest) CreateIssuerQuoteRequest(createIssuerQuoteRequest CreateIssuerQuoteRequest) ApiCreateIssuerQuoteRequest {
	r.createIssuerQuoteRequest = &createIssuerQuoteRequest
	return r
}

func (r ApiCreateIssuerQuoteRequest) Execute() (*CreateIssuerQuoteResponse, *http.Response, error) {
	return r.ApiService.CreateIssuerQuoteExecute(r)
}

/*
CreateIssuerQuote Create Issuer Quote

Creates a request for a quote where Paxos is the issuer. Note that PAXG quotes will be unavailable when the London gold market is closed.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateIssuerQuoteRequest
*/
func (a *IssuerQuotesAPIService) CreateIssuerQuote(ctx context.Context) ApiCreateIssuerQuoteRequest {
	return ApiCreateIssuerQuoteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CreateIssuerQuoteResponse
func (a *IssuerQuotesAPIService) CreateIssuerQuoteExecute(r ApiCreateIssuerQuoteRequest) (*CreateIssuerQuoteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateIssuerQuoteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuerQuotesAPIService.CreateIssuerQuote")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/issuer-quote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createIssuerQuoteRequest == nil {
		return localVarReturnValue, nil, reportError("createIssuerQuoteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createIssuerQuoteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateIssuerQuoteExecutionRequest struct {
	ctx context.Context
	ApiService *IssuerQuotesAPIService
	quoteId string
	exchangePublicCreateIssuerQuoteExecutionBody *ExchangePublicCreateIssuerQuoteExecutionBody
}

func (r ApiCreateIssuerQuoteExecutionRequest) ExchangePublicCreateIssuerQuoteExecutionBody(exchangePublicCreateIssuerQuoteExecutionBody ExchangePublicCreateIssuerQuoteExecutionBody) ApiCreateIssuerQuoteExecutionRequest {
	r.exchangePublicCreateIssuerQuoteExecutionBody = &exchangePublicCreateIssuerQuoteExecutionBody
	return r
}

func (r ApiCreateIssuerQuoteExecutionRequest) Execute() (*CreateIssuerQuoteExecutionResponse, *http.Response, error) {
	return r.ApiService.CreateIssuerQuoteExecutionExecute(r)
}

/*
CreateIssuerQuoteExecution Create Issuer Quote Execution

Executes on a quote where Paxos is the issuer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param quoteId The ID of the associated issuer quote to execute.
 @return ApiCreateIssuerQuoteExecutionRequest
*/
func (a *IssuerQuotesAPIService) CreateIssuerQuoteExecution(ctx context.Context, quoteId string) ApiCreateIssuerQuoteExecutionRequest {
	return ApiCreateIssuerQuoteExecutionRequest{
		ApiService: a,
		ctx: ctx,
		quoteId: quoteId,
	}
}

// Execute executes the request
//  @return CreateIssuerQuoteExecutionResponse
func (a *IssuerQuotesAPIService) CreateIssuerQuoteExecutionExecute(r ApiCreateIssuerQuoteExecutionRequest) (*CreateIssuerQuoteExecutionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateIssuerQuoteExecutionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuerQuotesAPIService.CreateIssuerQuoteExecution")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/issuer-quote/{quote_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"quote_id"+"}", url.PathEscape(parameterValueToString(r.quoteId, "quoteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exchangePublicCreateIssuerQuoteExecutionBody == nil {
		return localVarReturnValue, nil, reportError("exchangePublicCreateIssuerQuoteExecutionBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exchangePublicCreateIssuerQuoteExecutionBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListIssuerQuoteExecutionsRequest struct {
	ctx context.Context
	ApiService *IssuerQuotesAPIService
	profileId *string
	status *[]string
	createdRangeBegin *time.Time
	createdRangeEnd *time.Time
	limit *int32
	pageCursor *string
	order *string
}

// Optionally filter by the target profile of the issuer quote execution.
func (r ApiListIssuerQuoteExecutionsRequest) ProfileId(profileId string) ApiListIssuerQuoteExecutionsRequest {
	r.profileId = &profileId
	return r
}

// Optionally filter by status.
func (r ApiListIssuerQuoteExecutionsRequest) Status(status []string) ApiListIssuerQuoteExecutionsRequest {
	r.status = &status
	return r
}

// Only return records after this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIssuerQuoteExecutionsRequest) CreatedRangeBegin(createdRangeBegin time.Time) ApiListIssuerQuoteExecutionsRequest {
	r.createdRangeBegin = &createdRangeBegin
	return r
}

// Only return records before this timestamp, inclusive. RFC3339 format, like &#x60;2006-01-02T15:04:05Z&#x60;.
func (r ApiListIssuerQuoteExecutionsRequest) CreatedRangeEnd(createdRangeEnd time.Time) ApiListIssuerQuoteExecutionsRequest {
	r.createdRangeEnd = &createdRangeEnd
	return r
}

// Number of results to return. Defaults to 100 if no limit provided. Maximum 1000.
func (r ApiListIssuerQuoteExecutionsRequest) Limit(limit int32) ApiListIssuerQuoteExecutionsRequest {
	r.limit = &limit
	return r
}

// Cursor for getting the next page of results. When the number of items returned is fewer than the limit, there is currently no next page.
func (r ApiListIssuerQuoteExecutionsRequest) PageCursor(pageCursor string) ApiListIssuerQuoteExecutionsRequest {
	r.pageCursor = &pageCursor
	return r
}

// Determines whether the items are returned in ascending (ASC), or descending (DESC) order. Sorted by created at timestamp. Defaults to DESC.
func (r ApiListIssuerQuoteExecutionsRequest) Order(order string) ApiListIssuerQuoteExecutionsRequest {
	r.order = &order
	return r
}

func (r ApiListIssuerQuoteExecutionsRequest) Execute() (*ListIssuerQuoteExecutionsResponse, *http.Response, error) {
	return r.ApiService.ListIssuerQuoteExecutionsExecute(r)
}

/*
ListIssuerQuoteExecutions List Issuer Quote Executions

Retrieves full details of quote executions where Paxos is the issuer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListIssuerQuoteExecutionsRequest
*/
func (a *IssuerQuotesAPIService) ListIssuerQuoteExecutions(ctx context.Context) ApiListIssuerQuoteExecutionsRequest {
	return ApiListIssuerQuoteExecutionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListIssuerQuoteExecutionsResponse
func (a *IssuerQuotesAPIService) ListIssuerQuoteExecutionsExecute(r ApiListIssuerQuoteExecutionsRequest) (*ListIssuerQuoteExecutionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListIssuerQuoteExecutionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "IssuerQuotesAPIService.ListIssuerQuoteExecutions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/issuer-quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.profileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile_id", r.profileId, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.createdRangeBegin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_range.begin", r.createdRangeBegin, "")
	}
	if r.createdRangeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_range.end", r.createdRangeEnd, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.pageCursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_cursor", r.pageCursor, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
